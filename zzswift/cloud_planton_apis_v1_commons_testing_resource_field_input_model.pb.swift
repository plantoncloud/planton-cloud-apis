// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: cloud/planton/apis/v1/commons/testing/resource/field/input/model.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// A message with a string field that must match a regex, and a string field without regex.
public struct Cloud_Planton_Apis_V1_Commons_Testing_Resource_Field_Input_RegexFieldsTest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var regexStringField: String = String()

  public var noRegexStringField: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Cloud_Planton_Apis_V1_Commons_Testing_Resource_Field_Input_RegexFieldsProtoValidateTest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var regexStringField: String = String()

  public var noRegexStringField: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// A message with a string field that must match a regex, with no error message specified.
public struct Cloud_Planton_Apis_V1_Commons_Testing_Resource_Field_Input_RegexFieldsTestNoErrorMessage {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var regexStringField: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// A message with a nested message that contains a string field that must match a regex.
public struct Cloud_Planton_Apis_V1_Commons_Testing_Resource_Field_Input_NestedRegexFieldsTest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var nestedRegexField: Cloud_Planton_Apis_V1_Commons_Testing_Resource_Field_Input_RegexFieldsTest {
    get {return _nestedRegexField ?? Cloud_Planton_Apis_V1_Commons_Testing_Resource_Field_Input_RegexFieldsTest()}
    set {_nestedRegexField = newValue}
  }
  /// Returns true if `nestedRegexField` has been explicitly set.
  public var hasNestedRegexField: Bool {return self._nestedRegexField != nil}
  /// Clears the value of `nestedRegexField`. Subsequent reads from it will return its default value.
  public mutating func clearNestedRegexField() {self._nestedRegexField = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _nestedRegexField: Cloud_Planton_Apis_V1_Commons_Testing_Resource_Field_Input_RegexFieldsTest? = nil
}

/// A message with a required field and a non-required field.
public struct Cloud_Planton_Apis_V1_Commons_Testing_Resource_Field_Input_RequiredFieldsTest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var requiredStringField: String = String()

  public var notRequiredStringField: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// A message with a required string field that must match a regex.
public struct Cloud_Planton_Apis_V1_Commons_Testing_Resource_Field_Input_RequiredFieldsWithRegexTest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var regexRequiredStringField: String = String()

  public var noRegexRequiredStringField: String = String()

  public var noRulesString: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// A message with a required field that must be a specific nested message.
public struct Cloud_Planton_Apis_V1_Commons_Testing_Resource_Field_Input_RequiredNestedMessageTest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var nestedRequiredField: Cloud_Planton_Apis_V1_Commons_Testing_Resource_Field_Input_RequiredFieldsTest {
    get {return _nestedRequiredField ?? Cloud_Planton_Apis_V1_Commons_Testing_Resource_Field_Input_RequiredFieldsTest()}
    set {_nestedRequiredField = newValue}
  }
  /// Returns true if `nestedRequiredField` has been explicitly set.
  public var hasNestedRequiredField: Bool {return self._nestedRequiredField != nil}
  /// Clears the value of `nestedRequiredField`. Subsequent reads from it will return its default value.
  public mutating func clearNestedRequiredField() {self._nestedRequiredField = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _nestedRequiredField: Cloud_Planton_Apis_V1_Commons_Testing_Resource_Field_Input_RequiredFieldsTest? = nil
}

/// A message with string fields having min and max length constraints.
public struct Cloud_Planton_Apis_V1_Commons_Testing_Resource_Field_Input_StringLengthFieldsTest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var shortStringField: String = String()

  public var longStringField: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// A message with nested message containing string fields having min and max length constraints.
public struct Cloud_Planton_Apis_V1_Commons_Testing_Resource_Field_Input_NestedStringLengthFieldsTest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var nestedStringLengthField: Cloud_Planton_Apis_V1_Commons_Testing_Resource_Field_Input_StringLengthFieldsTest {
    get {return _nestedStringLengthField ?? Cloud_Planton_Apis_V1_Commons_Testing_Resource_Field_Input_StringLengthFieldsTest()}
    set {_nestedStringLengthField = newValue}
  }
  /// Returns true if `nestedStringLengthField` has been explicitly set.
  public var hasNestedStringLengthField: Bool {return self._nestedStringLengthField != nil}
  /// Clears the value of `nestedStringLengthField`. Subsequent reads from it will return its default value.
  public mutating func clearNestedStringLengthField() {self._nestedStringLengthField = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _nestedStringLengthField: Cloud_Planton_Apis_V1_Commons_Testing_Resource_Field_Input_StringLengthFieldsTest? = nil
}

/// A message with enum field.
public struct Cloud_Planton_Apis_V1_Commons_Testing_Resource_Field_Input_EnumFieldTest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var enumField: Cloud_Planton_Apis_V1_Commons_Testing_Resource_Field_Input_EnumFieldTest.SampleEnum = .unspecified

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum SampleEnum: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case unspecified // = 0
    case value1 // = 1
    case value2 // = 2
    case UNRECOGNIZED(Int)

    public init() {
      self = .unspecified
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecified
      case 1: self = .value1
      case 2: self = .value2
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unspecified: return 0
      case .value1: return 1
      case .value2: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension Cloud_Planton_Apis_V1_Commons_Testing_Resource_Field_Input_EnumFieldTest.SampleEnum: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Cloud_Planton_Apis_V1_Commons_Testing_Resource_Field_Input_EnumFieldTest.SampleEnum] = [
    .unspecified,
    .value1,
    .value2,
  ]
}

#endif  // swift(>=4.2)

/// A message with deeply nested messages.
public struct Cloud_Planton_Apis_V1_Commons_Testing_Resource_Field_Input_DeeplyNestedFieldTest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var nestedField1: Cloud_Planton_Apis_V1_Commons_Testing_Resource_Field_Input_NestedRegexFieldsTest {
    get {return _nestedField1 ?? Cloud_Planton_Apis_V1_Commons_Testing_Resource_Field_Input_NestedRegexFieldsTest()}
    set {_nestedField1 = newValue}
  }
  /// Returns true if `nestedField1` has been explicitly set.
  public var hasNestedField1: Bool {return self._nestedField1 != nil}
  /// Clears the value of `nestedField1`. Subsequent reads from it will return its default value.
  public mutating func clearNestedField1() {self._nestedField1 = nil}

  public var nestedField2: Cloud_Planton_Apis_V1_Commons_Testing_Resource_Field_Input_NestedStringLengthFieldsTest {
    get {return _nestedField2 ?? Cloud_Planton_Apis_V1_Commons_Testing_Resource_Field_Input_NestedStringLengthFieldsTest()}
    set {_nestedField2 = newValue}
  }
  /// Returns true if `nestedField2` has been explicitly set.
  public var hasNestedField2: Bool {return self._nestedField2 != nil}
  /// Clears the value of `nestedField2`. Subsequent reads from it will return its default value.
  public mutating func clearNestedField2() {self._nestedField2 = nil}

  public var nestedEnumField: Cloud_Planton_Apis_V1_Commons_Testing_Resource_Field_Input_EnumFieldTest {
    get {return _nestedEnumField ?? Cloud_Planton_Apis_V1_Commons_Testing_Resource_Field_Input_EnumFieldTest()}
    set {_nestedEnumField = newValue}
  }
  /// Returns true if `nestedEnumField` has been explicitly set.
  public var hasNestedEnumField: Bool {return self._nestedEnumField != nil}
  /// Clears the value of `nestedEnumField`. Subsequent reads from it will return its default value.
  public mutating func clearNestedEnumField() {self._nestedEnumField = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _nestedField1: Cloud_Planton_Apis_V1_Commons_Testing_Resource_Field_Input_NestedRegexFieldsTest? = nil
  fileprivate var _nestedField2: Cloud_Planton_Apis_V1_Commons_Testing_Resource_Field_Input_NestedStringLengthFieldsTest? = nil
  fileprivate var _nestedEnumField: Cloud_Planton_Apis_V1_Commons_Testing_Resource_Field_Input_EnumFieldTest? = nil
}

/// A message for testing multiple errors in the nested structure.
public struct Cloud_Planton_Apis_V1_Commons_Testing_Resource_Field_Input_MultipleErrorsTest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var field1: String = String()

  public var field2: Cloud_Planton_Apis_V1_Commons_Testing_Resource_Field_Input_DeeplyNestedFieldTest {
    get {return _field2 ?? Cloud_Planton_Apis_V1_Commons_Testing_Resource_Field_Input_DeeplyNestedFieldTest()}
    set {_field2 = newValue}
  }
  /// Returns true if `field2` has been explicitly set.
  public var hasField2: Bool {return self._field2 != nil}
  /// Clears the value of `field2`. Subsequent reads from it will return its default value.
  public mutating func clearField2() {self._field2 = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _field2: Cloud_Planton_Apis_V1_Commons_Testing_Resource_Field_Input_DeeplyNestedFieldTest? = nil
}

public struct Cloud_Planton_Apis_V1_Commons_Testing_Resource_Field_Input_MetadataIdRequiredTest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var metadata: Cloud_Planton_Apis_V1_Commons_Resource_Metadata {
    get {return _metadata ?? Cloud_Planton_Apis_V1_Commons_Resource_Metadata()}
    set {_metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  public var hasMetadata: Bool {return self._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  public mutating func clearMetadata() {self._metadata = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _metadata: Cloud_Planton_Apis_V1_Commons_Resource_Metadata? = nil
}

/// Test case 2: Message with metadata where id has regex constraint
public struct Cloud_Planton_Apis_V1_Commons_Testing_Resource_Field_Input_MetadataIdRegexTest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var metadata: Cloud_Planton_Apis_V1_Commons_Resource_Metadata {
    get {return _metadata ?? Cloud_Planton_Apis_V1_Commons_Resource_Metadata()}
    set {_metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  public var hasMetadata: Bool {return self._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  public mutating func clearMetadata() {self._metadata = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _metadata: Cloud_Planton_Apis_V1_Commons_Resource_Metadata? = nil
}

/// Test case 3: Message with metadata where id has min and max length constraints
public struct Cloud_Planton_Apis_V1_Commons_Testing_Resource_Field_Input_MetadataIdLengthTest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var metadata: Cloud_Planton_Apis_V1_Commons_Resource_Metadata {
    get {return _metadata ?? Cloud_Planton_Apis_V1_Commons_Resource_Metadata()}
    set {_metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  public var hasMetadata: Bool {return self._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  public mutating func clearMetadata() {self._metadata = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _metadata: Cloud_Planton_Apis_V1_Commons_Resource_Metadata? = nil
}

/// Test case 4: Message with metadata where is_id_computed is true (validations on id should be skipped)
public struct Cloud_Planton_Apis_V1_Commons_Testing_Resource_Field_Input_MetadataIdComputedTest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var metadata: Cloud_Planton_Apis_V1_Commons_Resource_Metadata {
    get {return _metadata ?? Cloud_Planton_Apis_V1_Commons_Resource_Metadata()}
    set {_metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  public var hasMetadata: Bool {return self._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  public mutating func clearMetadata() {self._metadata = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _metadata: Cloud_Planton_Apis_V1_Commons_Resource_Metadata? = nil
}

/// Test case 5: Message with metadata where name has regex and length constraints
public struct Cloud_Planton_Apis_V1_Commons_Testing_Resource_Field_Input_MetadataNameConstraintsTest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var metadata: Cloud_Planton_Apis_V1_Commons_Resource_Metadata {
    get {return _metadata ?? Cloud_Planton_Apis_V1_Commons_Resource_Metadata()}
    set {_metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  public var hasMetadata: Bool {return self._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  public mutating func clearMetadata() {self._metadata = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _metadata: Cloud_Planton_Apis_V1_Commons_Resource_Metadata? = nil
}

#if swift(>=5.5) && canImport(_Concurrency)
extension Cloud_Planton_Apis_V1_Commons_Testing_Resource_Field_Input_RegexFieldsTest: @unchecked Sendable {}
extension Cloud_Planton_Apis_V1_Commons_Testing_Resource_Field_Input_RegexFieldsProtoValidateTest: @unchecked Sendable {}
extension Cloud_Planton_Apis_V1_Commons_Testing_Resource_Field_Input_RegexFieldsTestNoErrorMessage: @unchecked Sendable {}
extension Cloud_Planton_Apis_V1_Commons_Testing_Resource_Field_Input_NestedRegexFieldsTest: @unchecked Sendable {}
extension Cloud_Planton_Apis_V1_Commons_Testing_Resource_Field_Input_RequiredFieldsTest: @unchecked Sendable {}
extension Cloud_Planton_Apis_V1_Commons_Testing_Resource_Field_Input_RequiredFieldsWithRegexTest: @unchecked Sendable {}
extension Cloud_Planton_Apis_V1_Commons_Testing_Resource_Field_Input_RequiredNestedMessageTest: @unchecked Sendable {}
extension Cloud_Planton_Apis_V1_Commons_Testing_Resource_Field_Input_StringLengthFieldsTest: @unchecked Sendable {}
extension Cloud_Planton_Apis_V1_Commons_Testing_Resource_Field_Input_NestedStringLengthFieldsTest: @unchecked Sendable {}
extension Cloud_Planton_Apis_V1_Commons_Testing_Resource_Field_Input_EnumFieldTest: @unchecked Sendable {}
extension Cloud_Planton_Apis_V1_Commons_Testing_Resource_Field_Input_EnumFieldTest.SampleEnum: @unchecked Sendable {}
extension Cloud_Planton_Apis_V1_Commons_Testing_Resource_Field_Input_DeeplyNestedFieldTest: @unchecked Sendable {}
extension Cloud_Planton_Apis_V1_Commons_Testing_Resource_Field_Input_MultipleErrorsTest: @unchecked Sendable {}
extension Cloud_Planton_Apis_V1_Commons_Testing_Resource_Field_Input_MetadataIdRequiredTest: @unchecked Sendable {}
extension Cloud_Planton_Apis_V1_Commons_Testing_Resource_Field_Input_MetadataIdRegexTest: @unchecked Sendable {}
extension Cloud_Planton_Apis_V1_Commons_Testing_Resource_Field_Input_MetadataIdLengthTest: @unchecked Sendable {}
extension Cloud_Planton_Apis_V1_Commons_Testing_Resource_Field_Input_MetadataIdComputedTest: @unchecked Sendable {}
extension Cloud_Planton_Apis_V1_Commons_Testing_Resource_Field_Input_MetadataNameConstraintsTest: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "cloud.planton.apis.v1.commons.testing.resource.field.input"

extension Cloud_Planton_Apis_V1_Commons_Testing_Resource_Field_Input_RegexFieldsTest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RegexFieldsTest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "regex_string_field"),
    2: .standard(proto: "no_regex_string_field"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.regexStringField) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.noRegexStringField) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.regexStringField.isEmpty {
      try visitor.visitSingularStringField(value: self.regexStringField, fieldNumber: 1)
    }
    if !self.noRegexStringField.isEmpty {
      try visitor.visitSingularStringField(value: self.noRegexStringField, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Cloud_Planton_Apis_V1_Commons_Testing_Resource_Field_Input_RegexFieldsTest, rhs: Cloud_Planton_Apis_V1_Commons_Testing_Resource_Field_Input_RegexFieldsTest) -> Bool {
    if lhs.regexStringField != rhs.regexStringField {return false}
    if lhs.noRegexStringField != rhs.noRegexStringField {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cloud_Planton_Apis_V1_Commons_Testing_Resource_Field_Input_RegexFieldsProtoValidateTest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RegexFieldsProtoValidateTest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "regex_string_field"),
    2: .standard(proto: "no_regex_string_field"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.regexStringField) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.noRegexStringField) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.regexStringField.isEmpty {
      try visitor.visitSingularStringField(value: self.regexStringField, fieldNumber: 1)
    }
    if !self.noRegexStringField.isEmpty {
      try visitor.visitSingularStringField(value: self.noRegexStringField, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Cloud_Planton_Apis_V1_Commons_Testing_Resource_Field_Input_RegexFieldsProtoValidateTest, rhs: Cloud_Planton_Apis_V1_Commons_Testing_Resource_Field_Input_RegexFieldsProtoValidateTest) -> Bool {
    if lhs.regexStringField != rhs.regexStringField {return false}
    if lhs.noRegexStringField != rhs.noRegexStringField {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cloud_Planton_Apis_V1_Commons_Testing_Resource_Field_Input_RegexFieldsTestNoErrorMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RegexFieldsTestNoErrorMessage"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "regex_string_field"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.regexStringField) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.regexStringField.isEmpty {
      try visitor.visitSingularStringField(value: self.regexStringField, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Cloud_Planton_Apis_V1_Commons_Testing_Resource_Field_Input_RegexFieldsTestNoErrorMessage, rhs: Cloud_Planton_Apis_V1_Commons_Testing_Resource_Field_Input_RegexFieldsTestNoErrorMessage) -> Bool {
    if lhs.regexStringField != rhs.regexStringField {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cloud_Planton_Apis_V1_Commons_Testing_Resource_Field_Input_NestedRegexFieldsTest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".NestedRegexFieldsTest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "nested_regex_field"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._nestedRegexField) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._nestedRegexField {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Cloud_Planton_Apis_V1_Commons_Testing_Resource_Field_Input_NestedRegexFieldsTest, rhs: Cloud_Planton_Apis_V1_Commons_Testing_Resource_Field_Input_NestedRegexFieldsTest) -> Bool {
    if lhs._nestedRegexField != rhs._nestedRegexField {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cloud_Planton_Apis_V1_Commons_Testing_Resource_Field_Input_RequiredFieldsTest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RequiredFieldsTest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "required_string_field"),
    2: .standard(proto: "not_required_string_field"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.requiredStringField) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.notRequiredStringField) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.requiredStringField.isEmpty {
      try visitor.visitSingularStringField(value: self.requiredStringField, fieldNumber: 1)
    }
    if !self.notRequiredStringField.isEmpty {
      try visitor.visitSingularStringField(value: self.notRequiredStringField, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Cloud_Planton_Apis_V1_Commons_Testing_Resource_Field_Input_RequiredFieldsTest, rhs: Cloud_Planton_Apis_V1_Commons_Testing_Resource_Field_Input_RequiredFieldsTest) -> Bool {
    if lhs.requiredStringField != rhs.requiredStringField {return false}
    if lhs.notRequiredStringField != rhs.notRequiredStringField {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cloud_Planton_Apis_V1_Commons_Testing_Resource_Field_Input_RequiredFieldsWithRegexTest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RequiredFieldsWithRegexTest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "regex_required_string_field"),
    2: .standard(proto: "no_regex_required_string_field"),
    3: .standard(proto: "no_rules_string"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.regexRequiredStringField) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.noRegexRequiredStringField) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.noRulesString) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.regexRequiredStringField.isEmpty {
      try visitor.visitSingularStringField(value: self.regexRequiredStringField, fieldNumber: 1)
    }
    if !self.noRegexRequiredStringField.isEmpty {
      try visitor.visitSingularStringField(value: self.noRegexRequiredStringField, fieldNumber: 2)
    }
    if !self.noRulesString.isEmpty {
      try visitor.visitSingularStringField(value: self.noRulesString, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Cloud_Planton_Apis_V1_Commons_Testing_Resource_Field_Input_RequiredFieldsWithRegexTest, rhs: Cloud_Planton_Apis_V1_Commons_Testing_Resource_Field_Input_RequiredFieldsWithRegexTest) -> Bool {
    if lhs.regexRequiredStringField != rhs.regexRequiredStringField {return false}
    if lhs.noRegexRequiredStringField != rhs.noRegexRequiredStringField {return false}
    if lhs.noRulesString != rhs.noRulesString {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cloud_Planton_Apis_V1_Commons_Testing_Resource_Field_Input_RequiredNestedMessageTest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RequiredNestedMessageTest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "nested_required_field"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._nestedRequiredField) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._nestedRequiredField {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Cloud_Planton_Apis_V1_Commons_Testing_Resource_Field_Input_RequiredNestedMessageTest, rhs: Cloud_Planton_Apis_V1_Commons_Testing_Resource_Field_Input_RequiredNestedMessageTest) -> Bool {
    if lhs._nestedRequiredField != rhs._nestedRequiredField {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cloud_Planton_Apis_V1_Commons_Testing_Resource_Field_Input_StringLengthFieldsTest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".StringLengthFieldsTest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "short_string_field"),
    2: .standard(proto: "long_string_field"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.shortStringField) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.longStringField) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.shortStringField.isEmpty {
      try visitor.visitSingularStringField(value: self.shortStringField, fieldNumber: 1)
    }
    if !self.longStringField.isEmpty {
      try visitor.visitSingularStringField(value: self.longStringField, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Cloud_Planton_Apis_V1_Commons_Testing_Resource_Field_Input_StringLengthFieldsTest, rhs: Cloud_Planton_Apis_V1_Commons_Testing_Resource_Field_Input_StringLengthFieldsTest) -> Bool {
    if lhs.shortStringField != rhs.shortStringField {return false}
    if lhs.longStringField != rhs.longStringField {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cloud_Planton_Apis_V1_Commons_Testing_Resource_Field_Input_NestedStringLengthFieldsTest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".NestedStringLengthFieldsTest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "nested_string_length_field"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._nestedStringLengthField) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._nestedStringLengthField {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Cloud_Planton_Apis_V1_Commons_Testing_Resource_Field_Input_NestedStringLengthFieldsTest, rhs: Cloud_Planton_Apis_V1_Commons_Testing_Resource_Field_Input_NestedStringLengthFieldsTest) -> Bool {
    if lhs._nestedStringLengthField != rhs._nestedStringLengthField {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cloud_Planton_Apis_V1_Commons_Testing_Resource_Field_Input_EnumFieldTest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".EnumFieldTest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "enum_field"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.enumField) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.enumField != .unspecified {
      try visitor.visitSingularEnumField(value: self.enumField, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Cloud_Planton_Apis_V1_Commons_Testing_Resource_Field_Input_EnumFieldTest, rhs: Cloud_Planton_Apis_V1_Commons_Testing_Resource_Field_Input_EnumFieldTest) -> Bool {
    if lhs.enumField != rhs.enumField {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cloud_Planton_Apis_V1_Commons_Testing_Resource_Field_Input_EnumFieldTest.SampleEnum: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNSPECIFIED"),
    1: .same(proto: "VALUE_1"),
    2: .same(proto: "VALUE_2"),
  ]
}

extension Cloud_Planton_Apis_V1_Commons_Testing_Resource_Field_Input_DeeplyNestedFieldTest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DeeplyNestedFieldTest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "nested_field_1"),
    2: .standard(proto: "nested_field_2"),
    3: .standard(proto: "nested_enum_field"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._nestedField1) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._nestedField2) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._nestedEnumField) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._nestedField1 {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._nestedField2 {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._nestedEnumField {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Cloud_Planton_Apis_V1_Commons_Testing_Resource_Field_Input_DeeplyNestedFieldTest, rhs: Cloud_Planton_Apis_V1_Commons_Testing_Resource_Field_Input_DeeplyNestedFieldTest) -> Bool {
    if lhs._nestedField1 != rhs._nestedField1 {return false}
    if lhs._nestedField2 != rhs._nestedField2 {return false}
    if lhs._nestedEnumField != rhs._nestedEnumField {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cloud_Planton_Apis_V1_Commons_Testing_Resource_Field_Input_MultipleErrorsTest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MultipleErrorsTest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "field_1"),
    2: .standard(proto: "field_2"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.field1) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._field2) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.field1.isEmpty {
      try visitor.visitSingularStringField(value: self.field1, fieldNumber: 1)
    }
    try { if let v = self._field2 {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Cloud_Planton_Apis_V1_Commons_Testing_Resource_Field_Input_MultipleErrorsTest, rhs: Cloud_Planton_Apis_V1_Commons_Testing_Resource_Field_Input_MultipleErrorsTest) -> Bool {
    if lhs.field1 != rhs.field1 {return false}
    if lhs._field2 != rhs._field2 {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cloud_Planton_Apis_V1_Commons_Testing_Resource_Field_Input_MetadataIdRequiredTest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MetadataIdRequiredTest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "metadata"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._metadata) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._metadata {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Cloud_Planton_Apis_V1_Commons_Testing_Resource_Field_Input_MetadataIdRequiredTest, rhs: Cloud_Planton_Apis_V1_Commons_Testing_Resource_Field_Input_MetadataIdRequiredTest) -> Bool {
    if lhs._metadata != rhs._metadata {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cloud_Planton_Apis_V1_Commons_Testing_Resource_Field_Input_MetadataIdRegexTest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MetadataIdRegexTest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "metadata"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._metadata) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._metadata {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Cloud_Planton_Apis_V1_Commons_Testing_Resource_Field_Input_MetadataIdRegexTest, rhs: Cloud_Planton_Apis_V1_Commons_Testing_Resource_Field_Input_MetadataIdRegexTest) -> Bool {
    if lhs._metadata != rhs._metadata {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cloud_Planton_Apis_V1_Commons_Testing_Resource_Field_Input_MetadataIdLengthTest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MetadataIdLengthTest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "metadata"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._metadata) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._metadata {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Cloud_Planton_Apis_V1_Commons_Testing_Resource_Field_Input_MetadataIdLengthTest, rhs: Cloud_Planton_Apis_V1_Commons_Testing_Resource_Field_Input_MetadataIdLengthTest) -> Bool {
    if lhs._metadata != rhs._metadata {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cloud_Planton_Apis_V1_Commons_Testing_Resource_Field_Input_MetadataIdComputedTest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MetadataIdComputedTest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "metadata"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._metadata) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._metadata {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Cloud_Planton_Apis_V1_Commons_Testing_Resource_Field_Input_MetadataIdComputedTest, rhs: Cloud_Planton_Apis_V1_Commons_Testing_Resource_Field_Input_MetadataIdComputedTest) -> Bool {
    if lhs._metadata != rhs._metadata {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cloud_Planton_Apis_V1_Commons_Testing_Resource_Field_Input_MetadataNameConstraintsTest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MetadataNameConstraintsTest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "metadata"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._metadata) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._metadata {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Cloud_Planton_Apis_V1_Commons_Testing_Resource_Field_Input_MetadataNameConstraintsTest, rhs: Cloud_Planton_Apis_V1_Commons_Testing_Resource_Field_Input_MetadataNameConstraintsTest) -> Bool {
    if lhs._metadata != rhs._metadata {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
