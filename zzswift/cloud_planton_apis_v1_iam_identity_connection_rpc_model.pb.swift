// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: cloud/planton/apis/v1/iam/identity/connection/rpc/model.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

///identity-connection used for linking a company's identity provider with planton cloud
public struct Cloud_Planton_Apis_V1_Iam_Identity_Connection_Rpc_IdentityConnection {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// resource api version
  public var apiVersion: String = String()

  /// resource kind
  public var kind: String = String()

  /// metadata for the resource
  /// id:
  ///
  /// naming convention "<idc>-<company_id>-<connection_name>".
  /// backend ignores the value provided by the client.
  ///
  /// name:
  ///
  /// a user preferred name of the identity connection.
  /// (important) spaces and special characters are not allowed except for hyphens.
  public var metadata: Cloud_Planton_Apis_V1_Commons_Resource_Metadata {
    get {return _metadata ?? Cloud_Planton_Apis_V1_Commons_Resource_Metadata()}
    set {_metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  public var hasMetadata: Bool {return self._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  public mutating func clearMetadata() {self._metadata = nil}

  /// resource spec
  public var spec: Cloud_Planton_Apis_V1_Iam_Identity_Connection_Rpc_IdentityConnectionSpec {
    get {return _spec ?? Cloud_Planton_Apis_V1_Iam_Identity_Connection_Rpc_IdentityConnectionSpec()}
    set {_spec = newValue}
  }
  /// Returns true if `spec` has been explicitly set.
  public var hasSpec: Bool {return self._spec != nil}
  /// Clears the value of `spec`. Subsequent reads from it will return its default value.
  public mutating func clearSpec() {self._spec = nil}

  /// resource status
  public var status: Cloud_Planton_Apis_V1_Iam_Identity_Connection_Rpc_IdentityConnectionStatus {
    get {return _status ?? Cloud_Planton_Apis_V1_Iam_Identity_Connection_Rpc_IdentityConnectionStatus()}
    set {_status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  public var hasStatus: Bool {return self._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  public mutating func clearStatus() {self._status = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _metadata: Cloud_Planton_Apis_V1_Commons_Resource_Metadata? = nil
  fileprivate var _spec: Cloud_Planton_Apis_V1_Iam_Identity_Connection_Rpc_IdentityConnectionSpec? = nil
  fileprivate var _status: Cloud_Planton_Apis_V1_Iam_Identity_Connection_Rpc_IdentityConnectionStatus? = nil
}

///specification for identity-connection
public struct Cloud_Planton_Apis_V1_Iam_Identity_Connection_Rpc_IdentityConnectionSpec {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// id of the company owning the identity connection.
  public var companyID: String {
    get {return _storage._companyID}
    set {_uniqueStorage()._companyID = newValue}
  }

  /// type of the identity connection.
  public var connectionType: Cloud_Planton_Apis_V1_Iam_Identity_Connection_Rpc_Enums_IdentityConnectionType {
    get {return _storage._connectionType}
    set {_uniqueStorage()._connectionType = newValue}
  }

  /// (read-only) id assigned by auth0 upon successful creation of the enterprise connection.
  /// this value is required to query auth0 system to get the details of the connection.
  public var identityConnectionIDOnIdp: String {
    get {return _storage._identityConnectionIDOnIdp}
    set {_uniqueStorage()._identityConnectionIDOnIdp = newValue}
  }

  /// (read-only) url of the identity connection on idp.
  /// this is constructed when a client requests for the account object.
  /// the format of the url for machine accounts is https://manage.auth0.com/dashboard/us/<tenant>/connections/enterprise/<connection-type-on-auth0>/<connection-id-on-auth0>/settings
  /// ex: https://manage.auth0.com/dashboard/us/planton-pcs-dev/connections/enterprise/google-apps/con_DBlqRlQ8dsPCvZnj/settings
  public var idpURL: String {
    get {return _storage._idpURL}
    set {_uniqueStorage()._idpURL = newValue}
  }

  /// saml connection details.
  /// this is conditionally required only when the connection type is "saml"
  public var samlConnection: Cloud_Planton_Apis_V1_Iam_Identity_Connection_Rpc_SamlConnection {
    get {return _storage._samlConnection ?? Cloud_Planton_Apis_V1_Iam_Identity_Connection_Rpc_SamlConnection()}
    set {_uniqueStorage()._samlConnection = newValue}
  }
  /// Returns true if `samlConnection` has been explicitly set.
  public var hasSamlConnection: Bool {return _storage._samlConnection != nil}
  /// Clears the value of `samlConnection`. Subsequent reads from it will return its default value.
  public mutating func clearSamlConnection() {_uniqueStorage()._samlConnection = nil}

  /// ldap connection details.
  /// this is conditionally required only when the connection type is "ldap"
  public var ldapConnection: Cloud_Planton_Apis_V1_Iam_Identity_Connection_Rpc_LdapConnection {
    get {return _storage._ldapConnection ?? Cloud_Planton_Apis_V1_Iam_Identity_Connection_Rpc_LdapConnection()}
    set {_uniqueStorage()._ldapConnection = newValue}
  }
  /// Returns true if `ldapConnection` has been explicitly set.
  public var hasLdapConnection: Bool {return _storage._ldapConnection != nil}
  /// Clears the value of `ldapConnection`. Subsequent reads from it will return its default value.
  public mutating func clearLdapConnection() {_uniqueStorage()._ldapConnection = nil}

  /// adfs connection details.
  /// this is conditionally required only when the connection type is "adfs"
  public var adfsConnection: Cloud_Planton_Apis_V1_Iam_Identity_Connection_Rpc_AdfsConnection {
    get {return _storage._adfsConnection ?? Cloud_Planton_Apis_V1_Iam_Identity_Connection_Rpc_AdfsConnection()}
    set {_uniqueStorage()._adfsConnection = newValue}
  }
  /// Returns true if `adfsConnection` has been explicitly set.
  public var hasAdfsConnection: Bool {return _storage._adfsConnection != nil}
  /// Clears the value of `adfsConnection`. Subsequent reads from it will return its default value.
  public mutating func clearAdfsConnection() {_uniqueStorage()._adfsConnection = nil}

  /// openid connection details.
  /// this is conditionally required only when the connection type is "openid"
  public var openidConnection: Cloud_Planton_Apis_V1_Iam_Identity_Connection_Rpc_OpenidConnection {
    get {return _storage._openidConnection ?? Cloud_Planton_Apis_V1_Iam_Identity_Connection_Rpc_OpenidConnection()}
    set {_uniqueStorage()._openidConnection = newValue}
  }
  /// Returns true if `openidConnection` has been explicitly set.
  public var hasOpenidConnection: Bool {return _storage._openidConnection != nil}
  /// Clears the value of `openidConnection`. Subsequent reads from it will return its default value.
  public mutating func clearOpenidConnection() {_uniqueStorage()._openidConnection = nil}

  /// okta workforce connection details.
  /// this is conditionally required only when the connection type is "okta_workforce"
  public var oktaWorkforceConnection: Cloud_Planton_Apis_V1_Iam_Identity_Connection_Rpc_OktaWorkforceConnection {
    get {return _storage._oktaWorkforceConnection ?? Cloud_Planton_Apis_V1_Iam_Identity_Connection_Rpc_OktaWorkforceConnection()}
    set {_uniqueStorage()._oktaWorkforceConnection = newValue}
  }
  /// Returns true if `oktaWorkforceConnection` has been explicitly set.
  public var hasOktaWorkforceConnection: Bool {return _storage._oktaWorkforceConnection != nil}
  /// Clears the value of `oktaWorkforceConnection`. Subsequent reads from it will return its default value.
  public mutating func clearOktaWorkforceConnection() {_uniqueStorage()._oktaWorkforceConnection = nil}

  /// azure active identity native connection details.
  /// this is conditionally required only when the connection type is "azure_active_identity_native"
  public var azureActiveIdentityNativeConnection: Cloud_Planton_Apis_V1_Iam_Identity_Connection_Rpc_AzureActiveDirectoryNativeConnection {
    get {return _storage._azureActiveIdentityNativeConnection ?? Cloud_Planton_Apis_V1_Iam_Identity_Connection_Rpc_AzureActiveDirectoryNativeConnection()}
    set {_uniqueStorage()._azureActiveIdentityNativeConnection = newValue}
  }
  /// Returns true if `azureActiveIdentityNativeConnection` has been explicitly set.
  public var hasAzureActiveIdentityNativeConnection: Bool {return _storage._azureActiveIdentityNativeConnection != nil}
  /// Clears the value of `azureActiveIdentityNativeConnection`. Subsequent reads from it will return its default value.
  public mutating func clearAzureActiveIdentityNativeConnection() {_uniqueStorage()._azureActiveIdentityNativeConnection = nil}

  /// ping federate connection details.
  /// this is conditionally required only when the connection type is "ping_federate"
  public var pingFederateConnection: Cloud_Planton_Apis_V1_Iam_Identity_Connection_Rpc_PingFederateConnection {
    get {return _storage._pingFederateConnection ?? Cloud_Planton_Apis_V1_Iam_Identity_Connection_Rpc_PingFederateConnection()}
    set {_uniqueStorage()._pingFederateConnection = newValue}
  }
  /// Returns true if `pingFederateConnection` has been explicitly set.
  public var hasPingFederateConnection: Bool {return _storage._pingFederateConnection != nil}
  /// Clears the value of `pingFederateConnection`. Subsequent reads from it will return its default value.
  public mutating func clearPingFederateConnection() {_uniqueStorage()._pingFederateConnection = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

///status for identity-connection
public struct Cloud_Planton_Apis_V1_Iam_Identity_Connection_Rpc_IdentityConnectionStatus {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// lifecycle of the resource
  public var lifecycle: Cloud_Planton_Apis_V1_Commons_Resource_ResourceLifecycle {
    get {return _lifecycle ?? Cloud_Planton_Apis_V1_Commons_Resource_ResourceLifecycle()}
    set {_lifecycle = newValue}
  }
  /// Returns true if `lifecycle` has been explicitly set.
  public var hasLifecycle: Bool {return self._lifecycle != nil}
  /// Clears the value of `lifecycle`. Subsequent reads from it will return its default value.
  public mutating func clearLifecycle() {self._lifecycle = nil}

  /// system audit info
  public var sysAudit: Cloud_Planton_Apis_V1_Commons_Audit_SysAudit {
    get {return _sysAudit ?? Cloud_Planton_Apis_V1_Commons_Audit_SysAudit()}
    set {_sysAudit = newValue}
  }
  /// Returns true if `sysAudit` has been explicitly set.
  public var hasSysAudit: Bool {return self._sysAudit != nil}
  /// Clears the value of `sysAudit`. Subsequent reads from it will return its default value.
  public mutating func clearSysAudit() {self._sysAudit = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _lifecycle: Cloud_Planton_Apis_V1_Commons_Resource_ResourceLifecycle? = nil
  fileprivate var _sysAudit: Cloud_Planton_Apis_V1_Commons_Audit_SysAudit? = nil
}

public struct Cloud_Planton_Apis_V1_Iam_Identity_Connection_Rpc_SamlConnection {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var signInURL: String = String()

  public var x509SigningCertBase64: String = String()

  public var enableSignOut: Bool = false

  public var signOutURL: String = String()

  public var userIDAttribute: String = String()

  public var signRequest: Bool = false

  public var signRequestAlgorithm: Cloud_Planton_Apis_V1_Iam_Identity_Connection_Rpc_Enums_SamlSignRequestAlgorithm = .unspecified

  public var signRequestAlgorithmDigest: Cloud_Planton_Apis_V1_Iam_Identity_Connection_Rpc_Enums_SamlSignRequestAlgorithmDigest = .unspecified

  public var protocolBinding: Cloud_Planton_Apis_V1_Iam_Identity_Connection_Rpc_Enums_SamlProtocolBinding = .unspecified

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Cloud_Planton_Apis_V1_Iam_Identity_Connection_Rpc_PingFederateConnection {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var serverURL: String = String()

  public var x509SigningCertBase64: String = String()

  public var signRequest: Bool = false

  public var signRequestAlgorithm: Cloud_Planton_Apis_V1_Iam_Identity_Connection_Rpc_Enums_SamlSignRequestAlgorithm = .unspecified

  public var signRequestAlgorithmDigest: Cloud_Planton_Apis_V1_Iam_Identity_Connection_Rpc_Enums_SamlSignRequestAlgorithmDigest = .unspecified

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Cloud_Planton_Apis_V1_Iam_Identity_Connection_Rpc_LdapConnection {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var idpDomains: [String] = []

  public var isCacheDisabled: Bool = false

  public var isClientSslCertificateAuthenticationRequired: Bool = false

  public var isKerberosEnabled: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Cloud_Planton_Apis_V1_Iam_Identity_Connection_Rpc_OpenidConnection {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var issueURL: String = String()

  public var clientID: String = String()

  public var callbackURL: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///active identity federation services connection
public struct Cloud_Planton_Apis_V1_Iam_Identity_Connection_Rpc_AdfsConnection {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var adfsMetadataURL: String = String()

  public var adfsMetadataFederationFileBase64: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Cloud_Planton_Apis_V1_Iam_Identity_Connection_Rpc_OktaWorkforceConnection {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var oktaDomain: String = String()

  public var clientID: String = String()

  public var clientSecret: String = String()

  public var callbackURL: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Cloud_Planton_Apis_V1_Iam_Identity_Connection_Rpc_AzureActiveDirectoryNativeConnection {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var microsoftAzureAdDomain: String = String()

  public var clientID: String = String()

  public var clientSecret: String = String()

  public var useCommonEndpoint: Bool = false

  public var identityApi: Cloud_Planton_Apis_V1_Iam_Identity_Connection_Rpc_Enums_MicrosoftIdentityApi = .unspecified

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// wrapper to get list of identity connections
public struct Cloud_Planton_Apis_V1_Iam_Identity_Connection_Rpc_IdentityConnections {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var entries: [Cloud_Planton_Apis_V1_Iam_Identity_Connection_Rpc_IdentityConnection] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// wrapper for user identity connection id.
public struct Cloud_Planton_Apis_V1_Iam_Identity_Connection_Rpc_IdentityConnectionId {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var value: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// input for paginated queries that require identity account id as input.
public struct Cloud_Planton_Apis_V1_Iam_Identity_Connection_Rpc_ListWithIdentityConnectionIdReq {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// identity connection id
  public var identityConnectionID: String = String()

  public var page: Cloud_Planton_Apis_V1_Commons_Rpc_Pagination_PageInfo {
    get {return _page ?? Cloud_Planton_Apis_V1_Commons_Rpc_Pagination_PageInfo()}
    set {_page = newValue}
  }
  /// Returns true if `page` has been explicitly set.
  public var hasPage: Bool {return self._page != nil}
  /// Clears the value of `page`. Subsequent reads from it will return its default value.
  public mutating func clearPage() {self._page = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _page: Cloud_Planton_Apis_V1_Commons_Rpc_Pagination_PageInfo? = nil
}

public struct Cloud_Planton_Apis_V1_Iam_Identity_Connection_Rpc_IdentityConnectionCompanyId {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var value: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

#if swift(>=5.5) && canImport(_Concurrency)
extension Cloud_Planton_Apis_V1_Iam_Identity_Connection_Rpc_IdentityConnection: @unchecked Sendable {}
extension Cloud_Planton_Apis_V1_Iam_Identity_Connection_Rpc_IdentityConnectionSpec: @unchecked Sendable {}
extension Cloud_Planton_Apis_V1_Iam_Identity_Connection_Rpc_IdentityConnectionStatus: @unchecked Sendable {}
extension Cloud_Planton_Apis_V1_Iam_Identity_Connection_Rpc_SamlConnection: @unchecked Sendable {}
extension Cloud_Planton_Apis_V1_Iam_Identity_Connection_Rpc_PingFederateConnection: @unchecked Sendable {}
extension Cloud_Planton_Apis_V1_Iam_Identity_Connection_Rpc_LdapConnection: @unchecked Sendable {}
extension Cloud_Planton_Apis_V1_Iam_Identity_Connection_Rpc_OpenidConnection: @unchecked Sendable {}
extension Cloud_Planton_Apis_V1_Iam_Identity_Connection_Rpc_AdfsConnection: @unchecked Sendable {}
extension Cloud_Planton_Apis_V1_Iam_Identity_Connection_Rpc_OktaWorkforceConnection: @unchecked Sendable {}
extension Cloud_Planton_Apis_V1_Iam_Identity_Connection_Rpc_AzureActiveDirectoryNativeConnection: @unchecked Sendable {}
extension Cloud_Planton_Apis_V1_Iam_Identity_Connection_Rpc_IdentityConnections: @unchecked Sendable {}
extension Cloud_Planton_Apis_V1_Iam_Identity_Connection_Rpc_IdentityConnectionId: @unchecked Sendable {}
extension Cloud_Planton_Apis_V1_Iam_Identity_Connection_Rpc_ListWithIdentityConnectionIdReq: @unchecked Sendable {}
extension Cloud_Planton_Apis_V1_Iam_Identity_Connection_Rpc_IdentityConnectionCompanyId: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "cloud.planton.apis.v1.iam.identity.connection.rpc"

extension Cloud_Planton_Apis_V1_Iam_Identity_Connection_Rpc_IdentityConnection: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".IdentityConnection"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "api_version"),
    2: .same(proto: "kind"),
    3: .same(proto: "metadata"),
    4: .same(proto: "spec"),
    5: .same(proto: "status"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.apiVersion) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.kind) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._metadata) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._spec) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._status) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.apiVersion.isEmpty {
      try visitor.visitSingularStringField(value: self.apiVersion, fieldNumber: 1)
    }
    if !self.kind.isEmpty {
      try visitor.visitSingularStringField(value: self.kind, fieldNumber: 2)
    }
    try { if let v = self._metadata {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._spec {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._status {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Cloud_Planton_Apis_V1_Iam_Identity_Connection_Rpc_IdentityConnection, rhs: Cloud_Planton_Apis_V1_Iam_Identity_Connection_Rpc_IdentityConnection) -> Bool {
    if lhs.apiVersion != rhs.apiVersion {return false}
    if lhs.kind != rhs.kind {return false}
    if lhs._metadata != rhs._metadata {return false}
    if lhs._spec != rhs._spec {return false}
    if lhs._status != rhs._status {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cloud_Planton_Apis_V1_Iam_Identity_Connection_Rpc_IdentityConnectionSpec: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".IdentityConnectionSpec"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "company_id"),
    2: .standard(proto: "connection_type"),
    5: .standard(proto: "identity_connection_id_on_idp"),
    6: .standard(proto: "idp_url"),
    7: .standard(proto: "saml_connection"),
    8: .standard(proto: "ldap_connection"),
    9: .standard(proto: "adfs_connection"),
    10: .standard(proto: "openid_connection"),
    11: .standard(proto: "okta_workforce_connection"),
    12: .standard(proto: "azure_active_identity_native_connection"),
    13: .standard(proto: "ping_federate_connection"),
  ]

  fileprivate class _StorageClass {
    var _companyID: String = String()
    var _connectionType: Cloud_Planton_Apis_V1_Iam_Identity_Connection_Rpc_Enums_IdentityConnectionType = .unspecified
    var _identityConnectionIDOnIdp: String = String()
    var _idpURL: String = String()
    var _samlConnection: Cloud_Planton_Apis_V1_Iam_Identity_Connection_Rpc_SamlConnection? = nil
    var _ldapConnection: Cloud_Planton_Apis_V1_Iam_Identity_Connection_Rpc_LdapConnection? = nil
    var _adfsConnection: Cloud_Planton_Apis_V1_Iam_Identity_Connection_Rpc_AdfsConnection? = nil
    var _openidConnection: Cloud_Planton_Apis_V1_Iam_Identity_Connection_Rpc_OpenidConnection? = nil
    var _oktaWorkforceConnection: Cloud_Planton_Apis_V1_Iam_Identity_Connection_Rpc_OktaWorkforceConnection? = nil
    var _azureActiveIdentityNativeConnection: Cloud_Planton_Apis_V1_Iam_Identity_Connection_Rpc_AzureActiveDirectoryNativeConnection? = nil
    var _pingFederateConnection: Cloud_Planton_Apis_V1_Iam_Identity_Connection_Rpc_PingFederateConnection? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _companyID = source._companyID
      _connectionType = source._connectionType
      _identityConnectionIDOnIdp = source._identityConnectionIDOnIdp
      _idpURL = source._idpURL
      _samlConnection = source._samlConnection
      _ldapConnection = source._ldapConnection
      _adfsConnection = source._adfsConnection
      _openidConnection = source._openidConnection
      _oktaWorkforceConnection = source._oktaWorkforceConnection
      _azureActiveIdentityNativeConnection = source._azureActiveIdentityNativeConnection
      _pingFederateConnection = source._pingFederateConnection
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._companyID) }()
        case 2: try { try decoder.decodeSingularEnumField(value: &_storage._connectionType) }()
        case 5: try { try decoder.decodeSingularStringField(value: &_storage._identityConnectionIDOnIdp) }()
        case 6: try { try decoder.decodeSingularStringField(value: &_storage._idpURL) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._samlConnection) }()
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._ldapConnection) }()
        case 9: try { try decoder.decodeSingularMessageField(value: &_storage._adfsConnection) }()
        case 10: try { try decoder.decodeSingularMessageField(value: &_storage._openidConnection) }()
        case 11: try { try decoder.decodeSingularMessageField(value: &_storage._oktaWorkforceConnection) }()
        case 12: try { try decoder.decodeSingularMessageField(value: &_storage._azureActiveIdentityNativeConnection) }()
        case 13: try { try decoder.decodeSingularMessageField(value: &_storage._pingFederateConnection) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._companyID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._companyID, fieldNumber: 1)
      }
      if _storage._connectionType != .unspecified {
        try visitor.visitSingularEnumField(value: _storage._connectionType, fieldNumber: 2)
      }
      if !_storage._identityConnectionIDOnIdp.isEmpty {
        try visitor.visitSingularStringField(value: _storage._identityConnectionIDOnIdp, fieldNumber: 5)
      }
      if !_storage._idpURL.isEmpty {
        try visitor.visitSingularStringField(value: _storage._idpURL, fieldNumber: 6)
      }
      try { if let v = _storage._samlConnection {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      } }()
      try { if let v = _storage._ldapConnection {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      } }()
      try { if let v = _storage._adfsConnection {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      } }()
      try { if let v = _storage._openidConnection {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      } }()
      try { if let v = _storage._oktaWorkforceConnection {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      } }()
      try { if let v = _storage._azureActiveIdentityNativeConnection {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
      } }()
      try { if let v = _storage._pingFederateConnection {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Cloud_Planton_Apis_V1_Iam_Identity_Connection_Rpc_IdentityConnectionSpec, rhs: Cloud_Planton_Apis_V1_Iam_Identity_Connection_Rpc_IdentityConnectionSpec) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._companyID != rhs_storage._companyID {return false}
        if _storage._connectionType != rhs_storage._connectionType {return false}
        if _storage._identityConnectionIDOnIdp != rhs_storage._identityConnectionIDOnIdp {return false}
        if _storage._idpURL != rhs_storage._idpURL {return false}
        if _storage._samlConnection != rhs_storage._samlConnection {return false}
        if _storage._ldapConnection != rhs_storage._ldapConnection {return false}
        if _storage._adfsConnection != rhs_storage._adfsConnection {return false}
        if _storage._openidConnection != rhs_storage._openidConnection {return false}
        if _storage._oktaWorkforceConnection != rhs_storage._oktaWorkforceConnection {return false}
        if _storage._azureActiveIdentityNativeConnection != rhs_storage._azureActiveIdentityNativeConnection {return false}
        if _storage._pingFederateConnection != rhs_storage._pingFederateConnection {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cloud_Planton_Apis_V1_Iam_Identity_Connection_Rpc_IdentityConnectionStatus: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".IdentityConnectionStatus"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    99: .same(proto: "lifecycle"),
    98: .standard(proto: "sys_audit"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 98: try { try decoder.decodeSingularMessageField(value: &self._sysAudit) }()
      case 99: try { try decoder.decodeSingularMessageField(value: &self._lifecycle) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._sysAudit {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 98)
    } }()
    try { if let v = self._lifecycle {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 99)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Cloud_Planton_Apis_V1_Iam_Identity_Connection_Rpc_IdentityConnectionStatus, rhs: Cloud_Planton_Apis_V1_Iam_Identity_Connection_Rpc_IdentityConnectionStatus) -> Bool {
    if lhs._lifecycle != rhs._lifecycle {return false}
    if lhs._sysAudit != rhs._sysAudit {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cloud_Planton_Apis_V1_Iam_Identity_Connection_Rpc_SamlConnection: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SamlConnection"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "sign_in_url"),
    2: .standard(proto: "x509_signing_cert_base64"),
    3: .standard(proto: "enable_sign_out"),
    4: .standard(proto: "sign_out_url"),
    5: .standard(proto: "user_id_attribute"),
    6: .standard(proto: "sign_request"),
    7: .standard(proto: "sign_request_algorithm"),
    8: .standard(proto: "sign_request_algorithm_digest"),
    9: .standard(proto: "protocol_binding"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.signInURL) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.x509SigningCertBase64) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.enableSignOut) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.signOutURL) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.userIDAttribute) }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self.signRequest) }()
      case 7: try { try decoder.decodeSingularEnumField(value: &self.signRequestAlgorithm) }()
      case 8: try { try decoder.decodeSingularEnumField(value: &self.signRequestAlgorithmDigest) }()
      case 9: try { try decoder.decodeSingularEnumField(value: &self.protocolBinding) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.signInURL.isEmpty {
      try visitor.visitSingularStringField(value: self.signInURL, fieldNumber: 1)
    }
    if !self.x509SigningCertBase64.isEmpty {
      try visitor.visitSingularStringField(value: self.x509SigningCertBase64, fieldNumber: 2)
    }
    if self.enableSignOut != false {
      try visitor.visitSingularBoolField(value: self.enableSignOut, fieldNumber: 3)
    }
    if !self.signOutURL.isEmpty {
      try visitor.visitSingularStringField(value: self.signOutURL, fieldNumber: 4)
    }
    if !self.userIDAttribute.isEmpty {
      try visitor.visitSingularStringField(value: self.userIDAttribute, fieldNumber: 5)
    }
    if self.signRequest != false {
      try visitor.visitSingularBoolField(value: self.signRequest, fieldNumber: 6)
    }
    if self.signRequestAlgorithm != .unspecified {
      try visitor.visitSingularEnumField(value: self.signRequestAlgorithm, fieldNumber: 7)
    }
    if self.signRequestAlgorithmDigest != .unspecified {
      try visitor.visitSingularEnumField(value: self.signRequestAlgorithmDigest, fieldNumber: 8)
    }
    if self.protocolBinding != .unspecified {
      try visitor.visitSingularEnumField(value: self.protocolBinding, fieldNumber: 9)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Cloud_Planton_Apis_V1_Iam_Identity_Connection_Rpc_SamlConnection, rhs: Cloud_Planton_Apis_V1_Iam_Identity_Connection_Rpc_SamlConnection) -> Bool {
    if lhs.signInURL != rhs.signInURL {return false}
    if lhs.x509SigningCertBase64 != rhs.x509SigningCertBase64 {return false}
    if lhs.enableSignOut != rhs.enableSignOut {return false}
    if lhs.signOutURL != rhs.signOutURL {return false}
    if lhs.userIDAttribute != rhs.userIDAttribute {return false}
    if lhs.signRequest != rhs.signRequest {return false}
    if lhs.signRequestAlgorithm != rhs.signRequestAlgorithm {return false}
    if lhs.signRequestAlgorithmDigest != rhs.signRequestAlgorithmDigest {return false}
    if lhs.protocolBinding != rhs.protocolBinding {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cloud_Planton_Apis_V1_Iam_Identity_Connection_Rpc_PingFederateConnection: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PingFederateConnection"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "server_url"),
    2: .standard(proto: "x509_signing_cert_base64"),
    3: .standard(proto: "sign_request"),
    4: .standard(proto: "sign_request_algorithm"),
    5: .standard(proto: "sign_request_algorithm_digest"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.serverURL) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.x509SigningCertBase64) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.signRequest) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self.signRequestAlgorithm) }()
      case 5: try { try decoder.decodeSingularEnumField(value: &self.signRequestAlgorithmDigest) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.serverURL.isEmpty {
      try visitor.visitSingularStringField(value: self.serverURL, fieldNumber: 1)
    }
    if !self.x509SigningCertBase64.isEmpty {
      try visitor.visitSingularStringField(value: self.x509SigningCertBase64, fieldNumber: 2)
    }
    if self.signRequest != false {
      try visitor.visitSingularBoolField(value: self.signRequest, fieldNumber: 3)
    }
    if self.signRequestAlgorithm != .unspecified {
      try visitor.visitSingularEnumField(value: self.signRequestAlgorithm, fieldNumber: 4)
    }
    if self.signRequestAlgorithmDigest != .unspecified {
      try visitor.visitSingularEnumField(value: self.signRequestAlgorithmDigest, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Cloud_Planton_Apis_V1_Iam_Identity_Connection_Rpc_PingFederateConnection, rhs: Cloud_Planton_Apis_V1_Iam_Identity_Connection_Rpc_PingFederateConnection) -> Bool {
    if lhs.serverURL != rhs.serverURL {return false}
    if lhs.x509SigningCertBase64 != rhs.x509SigningCertBase64 {return false}
    if lhs.signRequest != rhs.signRequest {return false}
    if lhs.signRequestAlgorithm != rhs.signRequestAlgorithm {return false}
    if lhs.signRequestAlgorithmDigest != rhs.signRequestAlgorithmDigest {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cloud_Planton_Apis_V1_Iam_Identity_Connection_Rpc_LdapConnection: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".LdapConnection"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "idp_domains"),
    2: .standard(proto: "is_cache_disabled"),
    3: .standard(proto: "is_client_ssl_certificate_authentication_required"),
    4: .standard(proto: "is_kerberos_enabled"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.idpDomains) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.isCacheDisabled) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.isClientSslCertificateAuthenticationRequired) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.isKerberosEnabled) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.idpDomains.isEmpty {
      try visitor.visitRepeatedStringField(value: self.idpDomains, fieldNumber: 1)
    }
    if self.isCacheDisabled != false {
      try visitor.visitSingularBoolField(value: self.isCacheDisabled, fieldNumber: 2)
    }
    if self.isClientSslCertificateAuthenticationRequired != false {
      try visitor.visitSingularBoolField(value: self.isClientSslCertificateAuthenticationRequired, fieldNumber: 3)
    }
    if self.isKerberosEnabled != false {
      try visitor.visitSingularBoolField(value: self.isKerberosEnabled, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Cloud_Planton_Apis_V1_Iam_Identity_Connection_Rpc_LdapConnection, rhs: Cloud_Planton_Apis_V1_Iam_Identity_Connection_Rpc_LdapConnection) -> Bool {
    if lhs.idpDomains != rhs.idpDomains {return false}
    if lhs.isCacheDisabled != rhs.isCacheDisabled {return false}
    if lhs.isClientSslCertificateAuthenticationRequired != rhs.isClientSslCertificateAuthenticationRequired {return false}
    if lhs.isKerberosEnabled != rhs.isKerberosEnabled {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cloud_Planton_Apis_V1_Iam_Identity_Connection_Rpc_OpenidConnection: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".OpenidConnection"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "issue_url"),
    2: .standard(proto: "client_id"),
    3: .standard(proto: "callback_url"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.issueURL) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.clientID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.callbackURL) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.issueURL.isEmpty {
      try visitor.visitSingularStringField(value: self.issueURL, fieldNumber: 1)
    }
    if !self.clientID.isEmpty {
      try visitor.visitSingularStringField(value: self.clientID, fieldNumber: 2)
    }
    if !self.callbackURL.isEmpty {
      try visitor.visitSingularStringField(value: self.callbackURL, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Cloud_Planton_Apis_V1_Iam_Identity_Connection_Rpc_OpenidConnection, rhs: Cloud_Planton_Apis_V1_Iam_Identity_Connection_Rpc_OpenidConnection) -> Bool {
    if lhs.issueURL != rhs.issueURL {return false}
    if lhs.clientID != rhs.clientID {return false}
    if lhs.callbackURL != rhs.callbackURL {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cloud_Planton_Apis_V1_Iam_Identity_Connection_Rpc_AdfsConnection: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AdfsConnection"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "adfs_metadata_url"),
    2: .standard(proto: "adfs_metadata_federation_file_base64"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.adfsMetadataURL) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.adfsMetadataFederationFileBase64) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.adfsMetadataURL.isEmpty {
      try visitor.visitSingularStringField(value: self.adfsMetadataURL, fieldNumber: 1)
    }
    if !self.adfsMetadataFederationFileBase64.isEmpty {
      try visitor.visitSingularStringField(value: self.adfsMetadataFederationFileBase64, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Cloud_Planton_Apis_V1_Iam_Identity_Connection_Rpc_AdfsConnection, rhs: Cloud_Planton_Apis_V1_Iam_Identity_Connection_Rpc_AdfsConnection) -> Bool {
    if lhs.adfsMetadataURL != rhs.adfsMetadataURL {return false}
    if lhs.adfsMetadataFederationFileBase64 != rhs.adfsMetadataFederationFileBase64 {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cloud_Planton_Apis_V1_Iam_Identity_Connection_Rpc_OktaWorkforceConnection: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".OktaWorkforceConnection"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "okta_domain"),
    2: .standard(proto: "client_id"),
    3: .standard(proto: "client_secret"),
    4: .standard(proto: "callback_url"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.oktaDomain) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.clientID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.clientSecret) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.callbackURL) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.oktaDomain.isEmpty {
      try visitor.visitSingularStringField(value: self.oktaDomain, fieldNumber: 1)
    }
    if !self.clientID.isEmpty {
      try visitor.visitSingularStringField(value: self.clientID, fieldNumber: 2)
    }
    if !self.clientSecret.isEmpty {
      try visitor.visitSingularStringField(value: self.clientSecret, fieldNumber: 3)
    }
    if !self.callbackURL.isEmpty {
      try visitor.visitSingularStringField(value: self.callbackURL, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Cloud_Planton_Apis_V1_Iam_Identity_Connection_Rpc_OktaWorkforceConnection, rhs: Cloud_Planton_Apis_V1_Iam_Identity_Connection_Rpc_OktaWorkforceConnection) -> Bool {
    if lhs.oktaDomain != rhs.oktaDomain {return false}
    if lhs.clientID != rhs.clientID {return false}
    if lhs.clientSecret != rhs.clientSecret {return false}
    if lhs.callbackURL != rhs.callbackURL {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cloud_Planton_Apis_V1_Iam_Identity_Connection_Rpc_AzureActiveDirectoryNativeConnection: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AzureActiveDirectoryNativeConnection"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "microsoft_azure_ad_domain"),
    2: .standard(proto: "client_id"),
    3: .standard(proto: "client_secret"),
    4: .standard(proto: "use_common_endpoint"),
    5: .standard(proto: "identity_api"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.microsoftAzureAdDomain) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.clientID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.clientSecret) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.useCommonEndpoint) }()
      case 5: try { try decoder.decodeSingularEnumField(value: &self.identityApi) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.microsoftAzureAdDomain.isEmpty {
      try visitor.visitSingularStringField(value: self.microsoftAzureAdDomain, fieldNumber: 1)
    }
    if !self.clientID.isEmpty {
      try visitor.visitSingularStringField(value: self.clientID, fieldNumber: 2)
    }
    if !self.clientSecret.isEmpty {
      try visitor.visitSingularStringField(value: self.clientSecret, fieldNumber: 3)
    }
    if self.useCommonEndpoint != false {
      try visitor.visitSingularBoolField(value: self.useCommonEndpoint, fieldNumber: 4)
    }
    if self.identityApi != .unspecified {
      try visitor.visitSingularEnumField(value: self.identityApi, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Cloud_Planton_Apis_V1_Iam_Identity_Connection_Rpc_AzureActiveDirectoryNativeConnection, rhs: Cloud_Planton_Apis_V1_Iam_Identity_Connection_Rpc_AzureActiveDirectoryNativeConnection) -> Bool {
    if lhs.microsoftAzureAdDomain != rhs.microsoftAzureAdDomain {return false}
    if lhs.clientID != rhs.clientID {return false}
    if lhs.clientSecret != rhs.clientSecret {return false}
    if lhs.useCommonEndpoint != rhs.useCommonEndpoint {return false}
    if lhs.identityApi != rhs.identityApi {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cloud_Planton_Apis_V1_Iam_Identity_Connection_Rpc_IdentityConnections: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".IdentityConnections"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "entries"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.entries) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.entries.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.entries, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Cloud_Planton_Apis_V1_Iam_Identity_Connection_Rpc_IdentityConnections, rhs: Cloud_Planton_Apis_V1_Iam_Identity_Connection_Rpc_IdentityConnections) -> Bool {
    if lhs.entries != rhs.entries {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cloud_Planton_Apis_V1_Iam_Identity_Connection_Rpc_IdentityConnectionId: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".IdentityConnectionId"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "value"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.value) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.value.isEmpty {
      try visitor.visitSingularStringField(value: self.value, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Cloud_Planton_Apis_V1_Iam_Identity_Connection_Rpc_IdentityConnectionId, rhs: Cloud_Planton_Apis_V1_Iam_Identity_Connection_Rpc_IdentityConnectionId) -> Bool {
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cloud_Planton_Apis_V1_Iam_Identity_Connection_Rpc_ListWithIdentityConnectionIdReq: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListWithIdentityConnectionIdReq"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "identity_connection_id"),
    2: .same(proto: "page"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.identityConnectionID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._page) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.identityConnectionID.isEmpty {
      try visitor.visitSingularStringField(value: self.identityConnectionID, fieldNumber: 1)
    }
    try { if let v = self._page {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Cloud_Planton_Apis_V1_Iam_Identity_Connection_Rpc_ListWithIdentityConnectionIdReq, rhs: Cloud_Planton_Apis_V1_Iam_Identity_Connection_Rpc_ListWithIdentityConnectionIdReq) -> Bool {
    if lhs.identityConnectionID != rhs.identityConnectionID {return false}
    if lhs._page != rhs._page {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cloud_Planton_Apis_V1_Iam_Identity_Connection_Rpc_IdentityConnectionCompanyId: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".IdentityConnectionCompanyId"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "value"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.value) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.value.isEmpty {
      try visitor.visitSingularStringField(value: self.value, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Cloud_Planton_Apis_V1_Iam_Identity_Connection_Rpc_IdentityConnectionCompanyId, rhs: Cloud_Planton_Apis_V1_Iam_Identity_Connection_Rpc_IdentityConnectionCompanyId) -> Bool {
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
