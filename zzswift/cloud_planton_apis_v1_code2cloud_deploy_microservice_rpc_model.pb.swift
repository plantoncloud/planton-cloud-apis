// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: cloud/planton/apis/v1/code2cloud/deploy/microservice/rpc/model.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

///microservice-instance
public struct Cloud_Planton_Apis_V1_Code2cloud_Deploy_Microservice_Rpc_MicroserviceInstance {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///resource api-version
  public var apiVersion: String {
    get {return _storage._apiVersion}
    set {_uniqueStorage()._apiVersion = newValue}
  }

  ///resource kind
  public var kind: String {
    get {return _storage._kind}
    set {_uniqueStorage()._kind = newValue}
  }

  ///resource metadata
  public var metadata: Cloud_Planton_Apis_V1_Commons_Resource_Metadata {
    get {return _storage._metadata ?? Cloud_Planton_Apis_V1_Commons_Resource_Metadata()}
    set {_uniqueStorage()._metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  public var hasMetadata: Bool {return _storage._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  public mutating func clearMetadata() {_uniqueStorage()._metadata = nil}

  ///spec
  public var spec: Cloud_Planton_Apis_V1_Code2cloud_Deploy_Microservice_Rpc_MicroserviceInstanceSpec {
    get {return _storage._spec ?? Cloud_Planton_Apis_V1_Code2cloud_Deploy_Microservice_Rpc_MicroserviceInstanceSpec()}
    set {_uniqueStorage()._spec = newValue}
  }
  /// Returns true if `spec` has been explicitly set.
  public var hasSpec: Bool {return _storage._spec != nil}
  /// Clears the value of `spec`. Subsequent reads from it will return its default value.
  public mutating func clearSpec() {_uniqueStorage()._spec = nil}

  ///status
  public var status: Cloud_Planton_Apis_V1_Code2cloud_Deploy_Microservice_Rpc_MicroserviceInstanceStatus {
    get {return _storage._status ?? Cloud_Planton_Apis_V1_Code2cloud_Deploy_Microservice_Rpc_MicroserviceInstanceStatus()}
    set {_uniqueStorage()._status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  public var hasStatus: Bool {return _storage._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  public mutating func clearStatus() {_uniqueStorage()._status = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

///microservice-instance spec
public struct Cloud_Planton_Apis_V1_Code2cloud_Deploy_Microservice_Rpc_MicroserviceInstanceSpec {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///resource parent
  public var owner: Cloud_Planton_Apis_V1_Commons_Resource_Owner_EnvironmentResourceOwner {
    get {return _owner ?? Cloud_Planton_Apis_V1_Commons_Resource_Owner_EnvironmentResourceOwner()}
    set {_owner = newValue}
  }
  /// Returns true if `owner` has been explicitly set.
  public var hasOwner: Bool {return self._owner != nil}
  /// Clears the value of `owner`. Subsequent reads from it will return its default value.
  public mutating func clearOwner() {self._owner = nil}

  ///version of the microservice being deployed. this is usually either "main" which is the default git branch name or
  ///review-<id> where id is the merge request number
  public var version: String = String()

  ///microservice runtime configuration for kubernetes provider
  public var kubernetes: Cloud_Planton_Apis_V1_Code2cloud_Deploy_Microservice_Rpc_MicroserviceInstanceSpecKubernetes {
    get {return _kubernetes ?? Cloud_Planton_Apis_V1_Code2cloud_Deploy_Microservice_Rpc_MicroserviceInstanceSpecKubernetes()}
    set {_kubernetes = newValue}
  }
  /// Returns true if `kubernetes` has been explicitly set.
  public var hasKubernetes: Bool {return self._kubernetes != nil}
  /// Clears the value of `kubernetes`. Subsequent reads from it will return its default value.
  public mutating func clearKubernetes() {self._kubernetes = nil}

  ///pipeline configuration required to update the microservice instance from ci/cd pipelines
  public var pipeline: Cloud_Planton_Apis_V1_Code2cloud_Deploy_Microservice_Rpc_MicroserviceInstanceSpecPipeline {
    get {return _pipeline ?? Cloud_Planton_Apis_V1_Code2cloud_Deploy_Microservice_Rpc_MicroserviceInstanceSpecPipeline()}
    set {_pipeline = newValue}
  }
  /// Returns true if `pipeline` has been explicitly set.
  public var hasPipeline: Bool {return self._pipeline != nil}
  /// Clears the value of `pipeline`. Subsequent reads from it will return its default value.
  public mutating func clearPipeline() {self._pipeline = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _owner: Cloud_Planton_Apis_V1_Commons_Resource_Owner_EnvironmentResourceOwner? = nil
  fileprivate var _kubernetes: Cloud_Planton_Apis_V1_Code2cloud_Deploy_Microservice_Rpc_MicroserviceInstanceSpecKubernetes? = nil
  fileprivate var _pipeline: Cloud_Planton_Apis_V1_Code2cloud_Deploy_Microservice_Rpc_MicroserviceInstanceSpecPipeline? = nil
}

///microservice-instance kubernetes spec
public struct Cloud_Planton_Apis_V1_Code2cloud_Deploy_Microservice_Rpc_MicroserviceInstanceSpecKubernetes {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///(required) type of the pod controller to use for the microservice deployment.
  ///default is set to "deployment".
  public var podControllerType: Cloud_Planton_Apis_V1_Commons_Kubernetes_Enums_PodControllerType {
    get {return _storage._podControllerType}
    set {_uniqueStorage()._podControllerType = newValue}
  }

  ///number of replicas
  public var minReplicas: Int32 {
    get {return _storage._minReplicas}
    set {_uniqueStorage()._minReplicas = newValue}
  }

  ///container spec
  public var container: Cloud_Planton_Apis_V1_Code2cloud_Deploy_Microservice_Rpc_MicroserviceInstanceSpecKubernetesContainer {
    get {return _storage._container ?? Cloud_Planton_Apis_V1_Code2cloud_Deploy_Microservice_Rpc_MicroserviceInstanceSpecKubernetesContainer()}
    set {_uniqueStorage()._container = newValue}
  }
  /// Returns true if `container` has been explicitly set.
  public var hasContainer: Bool {return _storage._container != nil}
  /// Clears the value of `container`. Subsequent reads from it will return its default value.
  public mutating func clearContainer() {_uniqueStorage()._container = nil}

  ///microservice instance network configuration on kubernetes
  public var network: Cloud_Planton_Apis_V1_Code2cloud_Deploy_Microservice_Rpc_MicroserviceInstanceSpecKubernetesNetwork {
    get {return _storage._network ?? Cloud_Planton_Apis_V1_Code2cloud_Deploy_Microservice_Rpc_MicroserviceInstanceSpecKubernetesNetwork()}
    set {_uniqueStorage()._network = newValue}
  }
  /// Returns true if `network` has been explicitly set.
  public var hasNetwork: Bool {return _storage._network != nil}
  /// Clears the value of `network`. Subsequent reads from it will return its default value.
  public mutating func clearNetwork() {_uniqueStorage()._network = nil}

  ///flag to toggle workload identity for the microservice
  ///default is set to "false".
  public var isWorkloadIdentityEnabled: Bool {
    get {return _storage._isWorkloadIdentityEnabled}
    set {_uniqueStorage()._isWorkloadIdentityEnabled = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

///microservice-instance-spec kubernetes container spec
public struct Cloud_Planton_Apis_V1_Code2cloud_Deploy_Microservice_Rpc_MicroserviceInstanceSpecKubernetesContainer {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///microservice app container
  public var app: Cloud_Planton_Apis_V1_Code2cloud_Deploy_Microservice_Rpc_MicroserviceInstanceSpecKubernetesAppContainer {
    get {return _app ?? Cloud_Planton_Apis_V1_Code2cloud_Deploy_Microservice_Rpc_MicroserviceInstanceSpecKubernetesAppContainer()}
    set {_app = newValue}
  }
  /// Returns true if `app` has been explicitly set.
  public var hasApp: Bool {return self._app != nil}
  /// Clears the value of `app`. Subsequent reads from it will return its default value.
  public mutating func clearApp() {self._app = nil}

  ///sidecar containers
  public var sidecars: [Cloud_Planton_Apis_V1_Commons_Kubernetes_Container] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _app: Cloud_Planton_Apis_V1_Code2cloud_Deploy_Microservice_Rpc_MicroserviceInstanceSpecKubernetesAppContainer? = nil
}

///microservice-instance-spec kubernetes app container spec
public struct Cloud_Planton_Apis_V1_Code2cloud_Deploy_Microservice_Rpc_MicroserviceInstanceSpecKubernetesAppContainer {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///container image. this value is computed during creation but is allowed for updates.
  ///value is computed by combining the docker-repo of the artifact-store configured for environment and code project path.
  ///
  ///pull-secret-name: name of the image pull secret to be configured in kubernetes Deployment resource.
  ///computed by looking up the container_image_artifact_store_id from the environment to which the
  ///microservice deployment is created.
  public var image: Cloud_Planton_Apis_V1_Commons_Kubernetes_ContainerImage {
    get {return _image ?? Cloud_Planton_Apis_V1_Commons_Kubernetes_ContainerImage()}
    set {_image = newValue}
  }
  /// Returns true if `image` has been explicitly set.
  public var hasImage: Bool {return self._image != nil}
  /// Clears the value of `image`. Subsequent reads from it will return its default value.
  public mutating func clearImage() {self._image = nil}

  ///container resources
  public var resources: Cloud_Planton_Apis_V1_Commons_Kubernetes_ContainerResources {
    get {return _resources ?? Cloud_Planton_Apis_V1_Commons_Kubernetes_ContainerResources()}
    set {_resources = newValue}
  }
  /// Returns true if `resources` has been explicitly set.
  public var hasResources: Bool {return self._resources != nil}
  /// Clears the value of `resources`. Subsequent reads from it will return its default value.
  public mutating func clearResources() {self._resources = nil}

  ///microservice-instance environment variables and secrets.
  public var env: Cloud_Planton_Apis_V1_Code2cloud_Deploy_Microservice_Rpc_MicroserviceInstanceSpecKubernetesAppContainerEnv {
    get {return _env ?? Cloud_Planton_Apis_V1_Code2cloud_Deploy_Microservice_Rpc_MicroserviceInstanceSpecKubernetesAppContainerEnv()}
    set {_env = newValue}
  }
  /// Returns true if `env` has been explicitly set.
  public var hasEnv: Bool {return self._env != nil}
  /// Clears the value of `env`. Subsequent reads from it will return its default value.
  public mutating func clearEnv() {self._env = nil}

  ///container volumes
  ///key is the mount path and value is size of the volume
  public var volumes: Dictionary<String,String> = [:]

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _image: Cloud_Planton_Apis_V1_Commons_Kubernetes_ContainerImage? = nil
  fileprivate var _resources: Cloud_Planton_Apis_V1_Commons_Kubernetes_ContainerResources? = nil
  fileprivate var _env: Cloud_Planton_Apis_V1_Code2cloud_Deploy_Microservice_Rpc_MicroserviceInstanceSpecKubernetesAppContainerEnv? = nil
}

///microservice-instance-spec kubernetes app container environment variables spec
public struct Cloud_Planton_Apis_V1_Code2cloud_Deploy_Microservice_Rpc_MicroserviceInstanceSpecKubernetesAppContainerEnv {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///map of variable
  public var variables: Dictionary<String,String> = [:]

  ///map of secrets
  public var secrets: Dictionary<String,String> = [:]

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///microservice-instance-spec kubernetes network spec
public struct Cloud_Planton_Apis_V1_Code2cloud_Deploy_Microservice_Rpc_MicroserviceInstanceSpecKubernetesNetwork {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///(required) application protocol for the microservice.
  ///the default is set to "http"
  ///https://kubernetes.io/docs/concepts/services-networking/service/#application-protocol.
  ///this field is used for setting up the name of the service port in kubernetes.
  ///this attribute is used during microservice deployment.
  ///this attribute is only relevant for deployment and stateful-set pod_controllers.
  public var appProtocol: String = String()

  ///container port
  public var containerPort: Int32 = 0

  ///kubernetes service port
  public var servicePort: Int32 = 0

  ///ingress-domain names.
  ///each ingress-domain name should already exist as a standard-endpoint domain for the product.
  ///endpoints will only created if the pod_controller_type is either deployment or stateful-set.
  public var ingressDomains: [String] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///microservice-instance-spec pipeline configuration
public struct Cloud_Planton_Apis_V1_Code2cloud_Deploy_Microservice_Rpc_MicroserviceInstanceSpecPipeline {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///flag to toggle pipelines for microservice-instance.
  ///default is "false".
  public var isEnabled: Bool = false

  ///id of the code project.
  ///allowed values are the list of code projects in the same product.
  public var codeProjectID: String = String()

  ///git branch configured to deploy new versions of microservice-instances
  public var gitBranch: String = String()

  ///toggle to enable or disable review environments to control the creation of ephemeral
  ///review environments for merge requests.
  ///default is "false".
  public var isReviewDeploymentsEnabled: Bool = false

  ///toggle for manual gate on ci/cd deployment jobs
  public var isManualGateRequired: Bool = false

  ///environment url to access the microservice deployed from the deployment job
  public var deploymentEnvironmentURL: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///microservice-instance-status
public struct Cloud_Planton_Apis_V1_Code2cloud_Deploy_Microservice_Rpc_MicroserviceInstanceStatus {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// resource lifecycle
  public var lifecycle: Cloud_Planton_Apis_V1_Commons_Resource_RunnableResourceLifecycle {
    get {return _lifecycle ?? Cloud_Planton_Apis_V1_Commons_Resource_RunnableResourceLifecycle()}
    set {_lifecycle = newValue}
  }
  /// Returns true if `lifecycle` has been explicitly set.
  public var hasLifecycle: Bool {return self._lifecycle != nil}
  /// Clears the value of `lifecycle`. Subsequent reads from it will return its default value.
  public mutating func clearLifecycle() {self._lifecycle = nil}

  /// system audit info
  public var sysAudit: Cloud_Planton_Apis_V1_Commons_Audit_SysAudit {
    get {return _sysAudit ?? Cloud_Planton_Apis_V1_Commons_Audit_SysAudit()}
    set {_sysAudit = newValue}
  }
  /// Returns true if `sysAudit` has been explicitly set.
  public var hasSysAudit: Bool {return self._sysAudit != nil}
  /// Clears the value of `sysAudit`. Subsequent reads from it will return its default value.
  public mutating func clearSysAudit() {self._sysAudit = nil}

  /// id of the stack-job
  public var stackJobID: String = String()

  ///microservice-instance kubernetes status
  public var kubernetes: Cloud_Planton_Apis_V1_Code2cloud_Deploy_Microservice_Rpc_MicroserviceInstanceStatusKubernetesStatus {
    get {return _kubernetes ?? Cloud_Planton_Apis_V1_Code2cloud_Deploy_Microservice_Rpc_MicroserviceInstanceStatusKubernetesStatus()}
    set {_kubernetes = newValue}
  }
  /// Returns true if `kubernetes` has been explicitly set.
  public var hasKubernetes: Bool {return self._kubernetes != nil}
  /// Clears the value of `kubernetes`. Subsequent reads from it will return its default value.
  public mutating func clearKubernetes() {self._kubernetes = nil}

  ///id of the service account created for the workload identity
  public var workloadIdentityAccountID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _lifecycle: Cloud_Planton_Apis_V1_Commons_Resource_RunnableResourceLifecycle? = nil
  fileprivate var _sysAudit: Cloud_Planton_Apis_V1_Commons_Audit_SysAudit? = nil
  fileprivate var _kubernetes: Cloud_Planton_Apis_V1_Code2cloud_Deploy_Microservice_Rpc_MicroserviceInstanceStatusKubernetesStatus? = nil
}

///microservice-instance-status  kubernetes status
public struct Cloud_Planton_Apis_V1_Code2cloud_Deploy_Microservice_Rpc_MicroserviceInstanceStatusKubernetesStatus {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///kubernetes namespace in which microservice-instance is created.
  public var namespace: String = String()

  ///kubernetes service name for microservice-instance.
  ///ex: main-microservice-instance
  ///in the above example, "main" is the name of the microservice-instance
  public var service: String = String()

  ///command to setup port-forwarding to open microservice-instance from developers laptop.
  ///this might come handy when microservice-instance ingress is disabled for security reasons.
  ///this is rendered by combining microservice_instance_kubernetes_service and kubernetes_namespace
  ///ex: kubectl port-forward svc/microservice_instance_kubernetes_service -n kubernetes_namespace 8080:8080
  ///running the command from this attribute makes it possible to access microservice-instance using http://localhost:8080
  public var portForwardCommand: String = String()

  ///kubernetes endpoint to connect to microservice-instance from the web browser.
  ///ex: main-microservice-instance.namespace.svc.instance.local:8080
  public var kubeEndpoint: String = String()

  ///public endpoint to open microservice-instance from clients outside kubernetes.
  ///ex: https://ms-planton-pcs-dev-account.dev.planton.live:8080
  public var ingressEndpoints: [String] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///wrapper for id field of microservice-instance
public struct Cloud_Planton_Apis_V1_Code2cloud_Deploy_Microservice_Rpc_MicroserviceInstanceId {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var value: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///list of microservice-instances
public struct Cloud_Planton_Apis_V1_Code2cloud_Deploy_Microservice_Rpc_MicroserviceInstances {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var entries: [Cloud_Planton_Apis_V1_Code2cloud_Deploy_Microservice_Rpc_MicroserviceInstance] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///response for paginated query to list microservice-instances
public struct Cloud_Planton_Apis_V1_Code2cloud_Deploy_Microservice_Rpc_MicroserviceInstanceList {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var totalPages: Int32 = 0

  public var entries: [Cloud_Planton_Apis_V1_Code2cloud_Deploy_Microservice_Rpc_MicroserviceInstance] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///input for query to get microservice-instance log stream
public struct Cloud_Planton_Apis_V1_Code2cloud_Deploy_Microservice_Rpc_GetMicroserviceInstanceLogStreamQueryInput {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///id of the microservice-instance
  public var microserviceInstanceID: String = String()

  ///https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.24/
  ///the number of lines from the end of the logs to show.
  ///if the value is not set or is set to 0, then a default value of 600 seconds is used.
  public var tailLines: Int32 = 0

  ///https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.24/
  ///a relative time in seconds before the current time from which to show logs.
  ///If this value precedes the time a pod was started, only logs since the pod start will be returned.
  ///If this value is in the future, no logs will be returned.
  ///if the value is not set or is set to 0, then a default value of 60 seconds is used.
  public var sinceSeconds: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///input for rpc queries that take environment-id and code-project-id as input
public struct Cloud_Planton_Apis_V1_Code2cloud_Deploy_Microservice_Rpc_ByEnvironmentIdByCodeProjectIdInput {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///id of the environment
  public var environmentID: String = String()

  ///id of the code project
  public var codeProjectID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///wrapper for microservice-instance env var map
public struct Cloud_Planton_Apis_V1_Code2cloud_Deploy_Microservice_Rpc_MicroserviceInstanceEnvVarMap {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var value: Dictionary<String,String> = [:]

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

#if swift(>=5.5) && canImport(_Concurrency)
extension Cloud_Planton_Apis_V1_Code2cloud_Deploy_Microservice_Rpc_MicroserviceInstance: @unchecked Sendable {}
extension Cloud_Planton_Apis_V1_Code2cloud_Deploy_Microservice_Rpc_MicroserviceInstanceSpec: @unchecked Sendable {}
extension Cloud_Planton_Apis_V1_Code2cloud_Deploy_Microservice_Rpc_MicroserviceInstanceSpecKubernetes: @unchecked Sendable {}
extension Cloud_Planton_Apis_V1_Code2cloud_Deploy_Microservice_Rpc_MicroserviceInstanceSpecKubernetesContainer: @unchecked Sendable {}
extension Cloud_Planton_Apis_V1_Code2cloud_Deploy_Microservice_Rpc_MicroserviceInstanceSpecKubernetesAppContainer: @unchecked Sendable {}
extension Cloud_Planton_Apis_V1_Code2cloud_Deploy_Microservice_Rpc_MicroserviceInstanceSpecKubernetesAppContainerEnv: @unchecked Sendable {}
extension Cloud_Planton_Apis_V1_Code2cloud_Deploy_Microservice_Rpc_MicroserviceInstanceSpecKubernetesNetwork: @unchecked Sendable {}
extension Cloud_Planton_Apis_V1_Code2cloud_Deploy_Microservice_Rpc_MicroserviceInstanceSpecPipeline: @unchecked Sendable {}
extension Cloud_Planton_Apis_V1_Code2cloud_Deploy_Microservice_Rpc_MicroserviceInstanceStatus: @unchecked Sendable {}
extension Cloud_Planton_Apis_V1_Code2cloud_Deploy_Microservice_Rpc_MicroserviceInstanceStatusKubernetesStatus: @unchecked Sendable {}
extension Cloud_Planton_Apis_V1_Code2cloud_Deploy_Microservice_Rpc_MicroserviceInstanceId: @unchecked Sendable {}
extension Cloud_Planton_Apis_V1_Code2cloud_Deploy_Microservice_Rpc_MicroserviceInstances: @unchecked Sendable {}
extension Cloud_Planton_Apis_V1_Code2cloud_Deploy_Microservice_Rpc_MicroserviceInstanceList: @unchecked Sendable {}
extension Cloud_Planton_Apis_V1_Code2cloud_Deploy_Microservice_Rpc_GetMicroserviceInstanceLogStreamQueryInput: @unchecked Sendable {}
extension Cloud_Planton_Apis_V1_Code2cloud_Deploy_Microservice_Rpc_ByEnvironmentIdByCodeProjectIdInput: @unchecked Sendable {}
extension Cloud_Planton_Apis_V1_Code2cloud_Deploy_Microservice_Rpc_MicroserviceInstanceEnvVarMap: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "cloud.planton.apis.v1.code2cloud.deploy.microservice.rpc"

extension Cloud_Planton_Apis_V1_Code2cloud_Deploy_Microservice_Rpc_MicroserviceInstance: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MicroserviceInstance"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "api_version"),
    2: .same(proto: "kind"),
    3: .same(proto: "metadata"),
    4: .same(proto: "spec"),
    5: .same(proto: "status"),
  ]

  fileprivate class _StorageClass {
    var _apiVersion: String = String()
    var _kind: String = String()
    var _metadata: Cloud_Planton_Apis_V1_Commons_Resource_Metadata? = nil
    var _spec: Cloud_Planton_Apis_V1_Code2cloud_Deploy_Microservice_Rpc_MicroserviceInstanceSpec? = nil
    var _status: Cloud_Planton_Apis_V1_Code2cloud_Deploy_Microservice_Rpc_MicroserviceInstanceStatus? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _apiVersion = source._apiVersion
      _kind = source._kind
      _metadata = source._metadata
      _spec = source._spec
      _status = source._status
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._apiVersion) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._kind) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._metadata) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._spec) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._status) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._apiVersion.isEmpty {
        try visitor.visitSingularStringField(value: _storage._apiVersion, fieldNumber: 1)
      }
      if !_storage._kind.isEmpty {
        try visitor.visitSingularStringField(value: _storage._kind, fieldNumber: 2)
      }
      try { if let v = _storage._metadata {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._spec {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._status {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Cloud_Planton_Apis_V1_Code2cloud_Deploy_Microservice_Rpc_MicroserviceInstance, rhs: Cloud_Planton_Apis_V1_Code2cloud_Deploy_Microservice_Rpc_MicroserviceInstance) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._apiVersion != rhs_storage._apiVersion {return false}
        if _storage._kind != rhs_storage._kind {return false}
        if _storage._metadata != rhs_storage._metadata {return false}
        if _storage._spec != rhs_storage._spec {return false}
        if _storage._status != rhs_storage._status {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cloud_Planton_Apis_V1_Code2cloud_Deploy_Microservice_Rpc_MicroserviceInstanceSpec: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MicroserviceInstanceSpec"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "owner"),
    2: .same(proto: "version"),
    3: .same(proto: "kubernetes"),
    4: .same(proto: "pipeline"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._owner) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.version) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._kubernetes) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._pipeline) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._owner {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.version.isEmpty {
      try visitor.visitSingularStringField(value: self.version, fieldNumber: 2)
    }
    try { if let v = self._kubernetes {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._pipeline {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Cloud_Planton_Apis_V1_Code2cloud_Deploy_Microservice_Rpc_MicroserviceInstanceSpec, rhs: Cloud_Planton_Apis_V1_Code2cloud_Deploy_Microservice_Rpc_MicroserviceInstanceSpec) -> Bool {
    if lhs._owner != rhs._owner {return false}
    if lhs.version != rhs.version {return false}
    if lhs._kubernetes != rhs._kubernetes {return false}
    if lhs._pipeline != rhs._pipeline {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cloud_Planton_Apis_V1_Code2cloud_Deploy_Microservice_Rpc_MicroserviceInstanceSpecKubernetes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MicroserviceInstanceSpecKubernetes"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "pod_controller_type"),
    2: .standard(proto: "min_replicas"),
    3: .same(proto: "container"),
    4: .same(proto: "network"),
    5: .standard(proto: "is_workload_identity_enabled"),
  ]

  fileprivate class _StorageClass {
    var _podControllerType: Cloud_Planton_Apis_V1_Commons_Kubernetes_Enums_PodControllerType = .unspecified
    var _minReplicas: Int32 = 0
    var _container: Cloud_Planton_Apis_V1_Code2cloud_Deploy_Microservice_Rpc_MicroserviceInstanceSpecKubernetesContainer? = nil
    var _network: Cloud_Planton_Apis_V1_Code2cloud_Deploy_Microservice_Rpc_MicroserviceInstanceSpecKubernetesNetwork? = nil
    var _isWorkloadIdentityEnabled: Bool = false

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _podControllerType = source._podControllerType
      _minReplicas = source._minReplicas
      _container = source._container
      _network = source._network
      _isWorkloadIdentityEnabled = source._isWorkloadIdentityEnabled
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularEnumField(value: &_storage._podControllerType) }()
        case 2: try { try decoder.decodeSingularInt32Field(value: &_storage._minReplicas) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._container) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._network) }()
        case 5: try { try decoder.decodeSingularBoolField(value: &_storage._isWorkloadIdentityEnabled) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if _storage._podControllerType != .unspecified {
        try visitor.visitSingularEnumField(value: _storage._podControllerType, fieldNumber: 1)
      }
      if _storage._minReplicas != 0 {
        try visitor.visitSingularInt32Field(value: _storage._minReplicas, fieldNumber: 2)
      }
      try { if let v = _storage._container {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._network {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      if _storage._isWorkloadIdentityEnabled != false {
        try visitor.visitSingularBoolField(value: _storage._isWorkloadIdentityEnabled, fieldNumber: 5)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Cloud_Planton_Apis_V1_Code2cloud_Deploy_Microservice_Rpc_MicroserviceInstanceSpecKubernetes, rhs: Cloud_Planton_Apis_V1_Code2cloud_Deploy_Microservice_Rpc_MicroserviceInstanceSpecKubernetes) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._podControllerType != rhs_storage._podControllerType {return false}
        if _storage._minReplicas != rhs_storage._minReplicas {return false}
        if _storage._container != rhs_storage._container {return false}
        if _storage._network != rhs_storage._network {return false}
        if _storage._isWorkloadIdentityEnabled != rhs_storage._isWorkloadIdentityEnabled {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cloud_Planton_Apis_V1_Code2cloud_Deploy_Microservice_Rpc_MicroserviceInstanceSpecKubernetesContainer: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MicroserviceInstanceSpecKubernetesContainer"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "app"),
    2: .same(proto: "sidecars"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._app) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.sidecars) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._app {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.sidecars.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.sidecars, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Cloud_Planton_Apis_V1_Code2cloud_Deploy_Microservice_Rpc_MicroserviceInstanceSpecKubernetesContainer, rhs: Cloud_Planton_Apis_V1_Code2cloud_Deploy_Microservice_Rpc_MicroserviceInstanceSpecKubernetesContainer) -> Bool {
    if lhs._app != rhs._app {return false}
    if lhs.sidecars != rhs.sidecars {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cloud_Planton_Apis_V1_Code2cloud_Deploy_Microservice_Rpc_MicroserviceInstanceSpecKubernetesAppContainer: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MicroserviceInstanceSpecKubernetesAppContainer"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "image"),
    2: .same(proto: "resources"),
    3: .same(proto: "env"),
    4: .same(proto: "volumes"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._image) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._resources) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._env) }()
      case 4: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &self.volumes) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._image {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._resources {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._env {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    if !self.volumes.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: self.volumes, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Cloud_Planton_Apis_V1_Code2cloud_Deploy_Microservice_Rpc_MicroserviceInstanceSpecKubernetesAppContainer, rhs: Cloud_Planton_Apis_V1_Code2cloud_Deploy_Microservice_Rpc_MicroserviceInstanceSpecKubernetesAppContainer) -> Bool {
    if lhs._image != rhs._image {return false}
    if lhs._resources != rhs._resources {return false}
    if lhs._env != rhs._env {return false}
    if lhs.volumes != rhs.volumes {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cloud_Planton_Apis_V1_Code2cloud_Deploy_Microservice_Rpc_MicroserviceInstanceSpecKubernetesAppContainerEnv: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MicroserviceInstanceSpecKubernetesAppContainerEnv"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "variables"),
    2: .same(proto: "secrets"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &self.variables) }()
      case 2: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &self.secrets) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.variables.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: self.variables, fieldNumber: 1)
    }
    if !self.secrets.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: self.secrets, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Cloud_Planton_Apis_V1_Code2cloud_Deploy_Microservice_Rpc_MicroserviceInstanceSpecKubernetesAppContainerEnv, rhs: Cloud_Planton_Apis_V1_Code2cloud_Deploy_Microservice_Rpc_MicroserviceInstanceSpecKubernetesAppContainerEnv) -> Bool {
    if lhs.variables != rhs.variables {return false}
    if lhs.secrets != rhs.secrets {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cloud_Planton_Apis_V1_Code2cloud_Deploy_Microservice_Rpc_MicroserviceInstanceSpecKubernetesNetwork: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MicroserviceInstanceSpecKubernetesNetwork"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "app_protocol"),
    2: .standard(proto: "container_port"),
    3: .standard(proto: "service_port"),
    4: .standard(proto: "ingress_domains"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.appProtocol) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.containerPort) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.servicePort) }()
      case 4: try { try decoder.decodeRepeatedStringField(value: &self.ingressDomains) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.appProtocol.isEmpty {
      try visitor.visitSingularStringField(value: self.appProtocol, fieldNumber: 1)
    }
    if self.containerPort != 0 {
      try visitor.visitSingularInt32Field(value: self.containerPort, fieldNumber: 2)
    }
    if self.servicePort != 0 {
      try visitor.visitSingularInt32Field(value: self.servicePort, fieldNumber: 3)
    }
    if !self.ingressDomains.isEmpty {
      try visitor.visitRepeatedStringField(value: self.ingressDomains, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Cloud_Planton_Apis_V1_Code2cloud_Deploy_Microservice_Rpc_MicroserviceInstanceSpecKubernetesNetwork, rhs: Cloud_Planton_Apis_V1_Code2cloud_Deploy_Microservice_Rpc_MicroserviceInstanceSpecKubernetesNetwork) -> Bool {
    if lhs.appProtocol != rhs.appProtocol {return false}
    if lhs.containerPort != rhs.containerPort {return false}
    if lhs.servicePort != rhs.servicePort {return false}
    if lhs.ingressDomains != rhs.ingressDomains {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cloud_Planton_Apis_V1_Code2cloud_Deploy_Microservice_Rpc_MicroserviceInstanceSpecPipeline: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MicroserviceInstanceSpecPipeline"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "is_enabled"),
    2: .standard(proto: "code_project_id"),
    3: .standard(proto: "git_branch"),
    4: .standard(proto: "is_review_deployments_enabled"),
    5: .standard(proto: "is_manual_gate_required"),
    6: .standard(proto: "deployment_environment_url"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.isEnabled) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.codeProjectID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.gitBranch) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.isReviewDeploymentsEnabled) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.isManualGateRequired) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.deploymentEnvironmentURL) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.isEnabled != false {
      try visitor.visitSingularBoolField(value: self.isEnabled, fieldNumber: 1)
    }
    if !self.codeProjectID.isEmpty {
      try visitor.visitSingularStringField(value: self.codeProjectID, fieldNumber: 2)
    }
    if !self.gitBranch.isEmpty {
      try visitor.visitSingularStringField(value: self.gitBranch, fieldNumber: 3)
    }
    if self.isReviewDeploymentsEnabled != false {
      try visitor.visitSingularBoolField(value: self.isReviewDeploymentsEnabled, fieldNumber: 4)
    }
    if self.isManualGateRequired != false {
      try visitor.visitSingularBoolField(value: self.isManualGateRequired, fieldNumber: 5)
    }
    if !self.deploymentEnvironmentURL.isEmpty {
      try visitor.visitSingularStringField(value: self.deploymentEnvironmentURL, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Cloud_Planton_Apis_V1_Code2cloud_Deploy_Microservice_Rpc_MicroserviceInstanceSpecPipeline, rhs: Cloud_Planton_Apis_V1_Code2cloud_Deploy_Microservice_Rpc_MicroserviceInstanceSpecPipeline) -> Bool {
    if lhs.isEnabled != rhs.isEnabled {return false}
    if lhs.codeProjectID != rhs.codeProjectID {return false}
    if lhs.gitBranch != rhs.gitBranch {return false}
    if lhs.isReviewDeploymentsEnabled != rhs.isReviewDeploymentsEnabled {return false}
    if lhs.isManualGateRequired != rhs.isManualGateRequired {return false}
    if lhs.deploymentEnvironmentURL != rhs.deploymentEnvironmentURL {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cloud_Planton_Apis_V1_Code2cloud_Deploy_Microservice_Rpc_MicroserviceInstanceStatus: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MicroserviceInstanceStatus"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    99: .same(proto: "lifecycle"),
    98: .standard(proto: "sys_audit"),
    97: .standard(proto: "stack_job_id"),
    1: .same(proto: "kubernetes"),
    2: .standard(proto: "workload_identity_account_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._kubernetes) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.workloadIdentityAccountID) }()
      case 97: try { try decoder.decodeSingularStringField(value: &self.stackJobID) }()
      case 98: try { try decoder.decodeSingularMessageField(value: &self._sysAudit) }()
      case 99: try { try decoder.decodeSingularMessageField(value: &self._lifecycle) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._kubernetes {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.workloadIdentityAccountID.isEmpty {
      try visitor.visitSingularStringField(value: self.workloadIdentityAccountID, fieldNumber: 2)
    }
    if !self.stackJobID.isEmpty {
      try visitor.visitSingularStringField(value: self.stackJobID, fieldNumber: 97)
    }
    try { if let v = self._sysAudit {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 98)
    } }()
    try { if let v = self._lifecycle {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 99)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Cloud_Planton_Apis_V1_Code2cloud_Deploy_Microservice_Rpc_MicroserviceInstanceStatus, rhs: Cloud_Planton_Apis_V1_Code2cloud_Deploy_Microservice_Rpc_MicroserviceInstanceStatus) -> Bool {
    if lhs._lifecycle != rhs._lifecycle {return false}
    if lhs._sysAudit != rhs._sysAudit {return false}
    if lhs.stackJobID != rhs.stackJobID {return false}
    if lhs._kubernetes != rhs._kubernetes {return false}
    if lhs.workloadIdentityAccountID != rhs.workloadIdentityAccountID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cloud_Planton_Apis_V1_Code2cloud_Deploy_Microservice_Rpc_MicroserviceInstanceStatusKubernetesStatus: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MicroserviceInstanceStatusKubernetesStatus"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "namespace"),
    2: .same(proto: "service"),
    3: .standard(proto: "port_forward_command"),
    4: .standard(proto: "kube_endpoint"),
    5: .standard(proto: "ingress_endpoints"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.namespace) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.service) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.portForwardCommand) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.kubeEndpoint) }()
      case 5: try { try decoder.decodeRepeatedStringField(value: &self.ingressEndpoints) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.namespace.isEmpty {
      try visitor.visitSingularStringField(value: self.namespace, fieldNumber: 1)
    }
    if !self.service.isEmpty {
      try visitor.visitSingularStringField(value: self.service, fieldNumber: 2)
    }
    if !self.portForwardCommand.isEmpty {
      try visitor.visitSingularStringField(value: self.portForwardCommand, fieldNumber: 3)
    }
    if !self.kubeEndpoint.isEmpty {
      try visitor.visitSingularStringField(value: self.kubeEndpoint, fieldNumber: 4)
    }
    if !self.ingressEndpoints.isEmpty {
      try visitor.visitRepeatedStringField(value: self.ingressEndpoints, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Cloud_Planton_Apis_V1_Code2cloud_Deploy_Microservice_Rpc_MicroserviceInstanceStatusKubernetesStatus, rhs: Cloud_Planton_Apis_V1_Code2cloud_Deploy_Microservice_Rpc_MicroserviceInstanceStatusKubernetesStatus) -> Bool {
    if lhs.namespace != rhs.namespace {return false}
    if lhs.service != rhs.service {return false}
    if lhs.portForwardCommand != rhs.portForwardCommand {return false}
    if lhs.kubeEndpoint != rhs.kubeEndpoint {return false}
    if lhs.ingressEndpoints != rhs.ingressEndpoints {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cloud_Planton_Apis_V1_Code2cloud_Deploy_Microservice_Rpc_MicroserviceInstanceId: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MicroserviceInstanceId"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "value"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.value) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.value.isEmpty {
      try visitor.visitSingularStringField(value: self.value, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Cloud_Planton_Apis_V1_Code2cloud_Deploy_Microservice_Rpc_MicroserviceInstanceId, rhs: Cloud_Planton_Apis_V1_Code2cloud_Deploy_Microservice_Rpc_MicroserviceInstanceId) -> Bool {
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cloud_Planton_Apis_V1_Code2cloud_Deploy_Microservice_Rpc_MicroserviceInstances: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MicroserviceInstances"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "entries"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.entries) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.entries.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.entries, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Cloud_Planton_Apis_V1_Code2cloud_Deploy_Microservice_Rpc_MicroserviceInstances, rhs: Cloud_Planton_Apis_V1_Code2cloud_Deploy_Microservice_Rpc_MicroserviceInstances) -> Bool {
    if lhs.entries != rhs.entries {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cloud_Planton_Apis_V1_Code2cloud_Deploy_Microservice_Rpc_MicroserviceInstanceList: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MicroserviceInstanceList"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "total_pages"),
    2: .same(proto: "entries"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.totalPages) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.entries) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.totalPages != 0 {
      try visitor.visitSingularInt32Field(value: self.totalPages, fieldNumber: 1)
    }
    if !self.entries.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.entries, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Cloud_Planton_Apis_V1_Code2cloud_Deploy_Microservice_Rpc_MicroserviceInstanceList, rhs: Cloud_Planton_Apis_V1_Code2cloud_Deploy_Microservice_Rpc_MicroserviceInstanceList) -> Bool {
    if lhs.totalPages != rhs.totalPages {return false}
    if lhs.entries != rhs.entries {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cloud_Planton_Apis_V1_Code2cloud_Deploy_Microservice_Rpc_GetMicroserviceInstanceLogStreamQueryInput: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetMicroserviceInstanceLogStreamQueryInput"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "microservice_instance_id"),
    2: .standard(proto: "tail_lines"),
    3: .standard(proto: "since_seconds"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.microserviceInstanceID) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.tailLines) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.sinceSeconds) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.microserviceInstanceID.isEmpty {
      try visitor.visitSingularStringField(value: self.microserviceInstanceID, fieldNumber: 1)
    }
    if self.tailLines != 0 {
      try visitor.visitSingularInt32Field(value: self.tailLines, fieldNumber: 2)
    }
    if self.sinceSeconds != 0 {
      try visitor.visitSingularInt32Field(value: self.sinceSeconds, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Cloud_Planton_Apis_V1_Code2cloud_Deploy_Microservice_Rpc_GetMicroserviceInstanceLogStreamQueryInput, rhs: Cloud_Planton_Apis_V1_Code2cloud_Deploy_Microservice_Rpc_GetMicroserviceInstanceLogStreamQueryInput) -> Bool {
    if lhs.microserviceInstanceID != rhs.microserviceInstanceID {return false}
    if lhs.tailLines != rhs.tailLines {return false}
    if lhs.sinceSeconds != rhs.sinceSeconds {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cloud_Planton_Apis_V1_Code2cloud_Deploy_Microservice_Rpc_ByEnvironmentIdByCodeProjectIdInput: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ByEnvironmentIdByCodeProjectIdInput"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "environment_id"),
    2: .standard(proto: "code_project_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.environmentID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.codeProjectID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.environmentID.isEmpty {
      try visitor.visitSingularStringField(value: self.environmentID, fieldNumber: 1)
    }
    if !self.codeProjectID.isEmpty {
      try visitor.visitSingularStringField(value: self.codeProjectID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Cloud_Planton_Apis_V1_Code2cloud_Deploy_Microservice_Rpc_ByEnvironmentIdByCodeProjectIdInput, rhs: Cloud_Planton_Apis_V1_Code2cloud_Deploy_Microservice_Rpc_ByEnvironmentIdByCodeProjectIdInput) -> Bool {
    if lhs.environmentID != rhs.environmentID {return false}
    if lhs.codeProjectID != rhs.codeProjectID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cloud_Planton_Apis_V1_Code2cloud_Deploy_Microservice_Rpc_MicroserviceInstanceEnvVarMap: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MicroserviceInstanceEnvVarMap"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "value"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &self.value) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.value.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: self.value, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Cloud_Planton_Apis_V1_Code2cloud_Deploy_Microservice_Rpc_MicroserviceInstanceEnvVarMap, rhs: Cloud_Planton_Apis_V1_Code2cloud_Deploy_Microservice_Rpc_MicroserviceInstanceEnvVarMap) -> Bool {
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
