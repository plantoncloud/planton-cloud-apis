// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: cloud/planton/apis/v1/integration/github/proxy/model.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

///github client info
public struct Cloud_Planton_Apis_V1_Integration_Github_Proxy_GithubClientInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///github host to send the request to ex: https://github.com
  public var githubHost: String = String()

  ///github authorization type
  public var authorizationType: Cloud_Planton_Apis_V1_Integration_Github_Proxy_Enums_GithubApiAuthorizationType = .unspecified

  ///api token to be used to query github server when authorization type is api token
  public var apiToken: String = String()

  ///github app installation details to be used to query github server when authorization type is github app
  public var githubAppInstallation: Cloud_Planton_Apis_V1_Integration_Github_Proxy_GithubAppInstallation {
    get {return _githubAppInstallation ?? Cloud_Planton_Apis_V1_Integration_Github_Proxy_GithubAppInstallation()}
    set {_githubAppInstallation = newValue}
  }
  /// Returns true if `githubAppInstallation` has been explicitly set.
  public var hasGithubAppInstallation: Bool {return self._githubAppInstallation != nil}
  /// Clears the value of `githubAppInstallation`. Subsequent reads from it will return its default value.
  public mutating func clearGithubAppInstallation() {self._githubAppInstallation = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _githubAppInstallation: Cloud_Planton_Apis_V1_Integration_Github_Proxy_GithubAppInstallation? = nil
}

///github app installation information
public struct Cloud_Planton_Apis_V1_Integration_Github_Proxy_GithubAppInstallation {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///id of the github app
  public var githubAppID: Int64 = 0

  ///base64 encoded private key generated for the github app
  public var githubAppPrivateKeyBase64: String = String()

  ///id of the github app installation
  public var githubAppInstallID: Int64 = 0

  ///type of the account of the github app installation
  public var installOwnerType: Cloud_Planton_Apis_V1_Code2cloud_Develop_Sourcecode_Server_Rpc_Enums_GithubAppInstallOwnerType = .githubAppInstallationOwnerTypeUnspecified

  ///id of the github app installation.
  ///this is the name of the organization when the app is installed on an organization and id of the user when
  ///the app is installed on a personal user account.
  ///this value is stored in the system as group_id_on_code_server_host attribute.
  public var githubAppInstallationOwnerID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///input to list organization or user repositories on github
///https://docs.github.com/en/rest/repos/repos?apiVersion=2022-11-28#list-organization-repositories
public struct Cloud_Planton_Apis_V1_Integration_Github_Proxy_ListRepositoriesQueryInput {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///github client info
  public var githubClientInfo: Cloud_Planton_Apis_V1_Integration_Github_Proxy_GithubClientInfo {
    get {return _githubClientInfo ?? Cloud_Planton_Apis_V1_Integration_Github_Proxy_GithubClientInfo()}
    set {_githubClientInfo = newValue}
  }
  /// Returns true if `githubClientInfo` has been explicitly set.
  public var hasGithubClientInfo: Bool {return self._githubClientInfo != nil}
  /// Clears the value of `githubClientInfo`. Subsequent reads from it will return its default value.
  public mutating func clearGithubClientInfo() {self._githubClientInfo = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _githubClientInfo: Cloud_Planton_Apis_V1_Integration_Github_Proxy_GithubClientInfo? = nil
}

///input to list organization or user repositories on github
///https://docs.github.com/en/rest/repos/repos?apiVersion=2022-11-28#list-organization-repositories
public struct Cloud_Planton_Apis_V1_Integration_Github_Proxy_GetRepositoryQueryInput {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///github client info
  public var githubClientInfo: Cloud_Planton_Apis_V1_Integration_Github_Proxy_GithubClientInfo {
    get {return _githubClientInfo ?? Cloud_Planton_Apis_V1_Integration_Github_Proxy_GithubClientInfo()}
    set {_githubClientInfo = newValue}
  }
  /// Returns true if `githubClientInfo` has been explicitly set.
  public var hasGithubClientInfo: Bool {return self._githubClientInfo != nil}
  /// Clears the value of `githubClientInfo`. Subsequent reads from it will return its default value.
  public mutating func clearGithubClientInfo() {self._githubClientInfo = nil}

  ///id of the repository on github
  public var repositoryID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _githubClientInfo: Cloud_Planton_Apis_V1_Integration_Github_Proxy_GithubClientInfo? = nil
}

///input for command to create a new git repository on github
public struct Cloud_Planton_Apis_V1_Integration_Github_Proxy_CreRepositoryCommandInput {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///github client info
  public var githubClientInfo: Cloud_Planton_Apis_V1_Integration_Github_Proxy_GithubClientInfo {
    get {return _githubClientInfo ?? Cloud_Planton_Apis_V1_Integration_Github_Proxy_GithubClientInfo()}
    set {_githubClientInfo = newValue}
  }
  /// Returns true if `githubClientInfo` has been explicitly set.
  public var hasGithubClientInfo: Bool {return self._githubClientInfo != nil}
  /// Clears the value of `githubClientInfo`. Subsequent reads from it will return its default value.
  public mutating func clearGithubClientInfo() {self._githubClientInfo = nil}

  ///name of the new repository to be created on github
  public var repositoryName: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _githubClientInfo: Cloud_Planton_Apis_V1_Integration_Github_Proxy_GithubClientInfo? = nil
}

///input for command to apply a cookiecutter on a code project on github
public struct Cloud_Planton_Apis_V1_Integration_Github_Proxy_GithubApplyTemplateCommandInput {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///github client info required to lookup template repo on github
  public var templateProjectGithubClientInfo: Cloud_Planton_Apis_V1_Integration_Github_Proxy_GithubClientInfo {
    get {return _storage._templateProjectGithubClientInfo ?? Cloud_Planton_Apis_V1_Integration_Github_Proxy_GithubClientInfo()}
    set {_uniqueStorage()._templateProjectGithubClientInfo = newValue}
  }
  /// Returns true if `templateProjectGithubClientInfo` has been explicitly set.
  public var hasTemplateProjectGithubClientInfo: Bool {return _storage._templateProjectGithubClientInfo != nil}
  /// Clears the value of `templateProjectGithubClientInfo`. Subsequent reads from it will return its default value.
  public mutating func clearTemplateProjectGithubClientInfo() {_uniqueStorage()._templateProjectGithubClientInfo = nil}

  ///github client info required to clone and push changes for target project
  public var targetProjectGithubClientInfo: Cloud_Planton_Apis_V1_Integration_Github_Proxy_GithubClientInfo {
    get {return _storage._targetProjectGithubClientInfo ?? Cloud_Planton_Apis_V1_Integration_Github_Proxy_GithubClientInfo()}
    set {_uniqueStorage()._targetProjectGithubClientInfo = newValue}
  }
  /// Returns true if `targetProjectGithubClientInfo` has been explicitly set.
  public var hasTargetProjectGithubClientInfo: Bool {return _storage._targetProjectGithubClientInfo != nil}
  /// Clears the value of `targetProjectGithubClientInfo`. Subsequent reads from it will return its default value.
  public mutating func clearTargetProjectGithubClientInfo() {_uniqueStorage()._targetProjectGithubClientInfo = nil}

  ///template code project
  public var templateProject: Cloud_Planton_Apis_V1_Code2cloud_Develop_Sourcecode_Project_Rpc_CodeProject {
    get {return _storage._templateProject ?? Cloud_Planton_Apis_V1_Code2cloud_Develop_Sourcecode_Project_Rpc_CodeProject()}
    set {_uniqueStorage()._templateProject = newValue}
  }
  /// Returns true if `templateProject` has been explicitly set.
  public var hasTemplateProject: Bool {return _storage._templateProject != nil}
  /// Clears the value of `templateProject`. Subsequent reads from it will return its default value.
  public mutating func clearTemplateProject() {_uniqueStorage()._templateProject = nil}

  ///code project for which the template should be applied
  public var targetCodeProject: Cloud_Planton_Apis_V1_Code2cloud_Develop_Sourcecode_Project_Rpc_CodeProject {
    get {return _storage._targetCodeProject ?? Cloud_Planton_Apis_V1_Code2cloud_Develop_Sourcecode_Project_Rpc_CodeProject()}
    set {_uniqueStorage()._targetCodeProject = newValue}
  }
  /// Returns true if `targetCodeProject` has been explicitly set.
  public var hasTargetCodeProject: Bool {return _storage._targetCodeProject != nil}
  /// Clears the value of `targetCodeProject`. Subsequent reads from it will return its default value.
  public mutating func clearTargetCodeProject() {_uniqueStorage()._targetCodeProject = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

///input for command to add list of secrets to a github repository
public struct Cloud_Planton_Apis_V1_Integration_Github_Proxy_AddSecretsToRepoCommandInput {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///github client info required to lookup template repo on github
  public var githubClientInfo: Cloud_Planton_Apis_V1_Integration_Github_Proxy_GithubClientInfo {
    get {return _githubClientInfo ?? Cloud_Planton_Apis_V1_Integration_Github_Proxy_GithubClientInfo()}
    set {_githubClientInfo = newValue}
  }
  /// Returns true if `githubClientInfo` has been explicitly set.
  public var hasGithubClientInfo: Bool {return self._githubClientInfo != nil}
  /// Clears the value of `githubClientInfo`. Subsequent reads from it will return its default value.
  public mutating func clearGithubClientInfo() {self._githubClientInfo = nil}

  ///id of the github repository to which the secrets are to be added
  public var githubRepositoryID: String = String()

  ///secrets to be added to the repository
  ///the key is the name of the secret and value is the value of the secret
  public var secrets: Dictionary<String,String> = [:]

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _githubClientInfo: Cloud_Planton_Apis_V1_Integration_Github_Proxy_GithubClientInfo? = nil
}

///input for command to add list of secrets to a github organization
public struct Cloud_Planton_Apis_V1_Integration_Github_Proxy_AddSecretsToOrgCommandInput {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///github client info required to lookup template repo on github
  public var githubClientInfo: Cloud_Planton_Apis_V1_Integration_Github_Proxy_GithubClientInfo {
    get {return _githubClientInfo ?? Cloud_Planton_Apis_V1_Integration_Github_Proxy_GithubClientInfo()}
    set {_githubClientInfo = newValue}
  }
  /// Returns true if `githubClientInfo` has been explicitly set.
  public var hasGithubClientInfo: Bool {return self._githubClientInfo != nil}
  /// Clears the value of `githubClientInfo`. Subsequent reads from it will return its default value.
  public mutating func clearGithubClientInfo() {self._githubClientInfo = nil}

  ///id of the github organization to which the secrets are to be added
  public var githubOrgID: String = String()

  ///secrets to be added to the organization
  ///the key is the name of the secret and value is the value of the secret
  public var secrets: Dictionary<String,String> = [:]

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _githubClientInfo: Cloud_Planton_Apis_V1_Integration_Github_Proxy_GithubClientInfo? = nil
}

///input for query to get code project profile of a github repository
public struct Cloud_Planton_Apis_V1_Integration_Github_Proxy_GetGithubCodeProjectProfileQueryInput {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///github client info required to clone github repository
  public var githubClientInfo: Cloud_Planton_Apis_V1_Integration_Github_Proxy_GithubClientInfo {
    get {return _githubClientInfo ?? Cloud_Planton_Apis_V1_Integration_Github_Proxy_GithubClientInfo()}
    set {_githubClientInfo = newValue}
  }
  /// Returns true if `githubClientInfo` has been explicitly set.
  public var hasGithubClientInfo: Bool {return self._githubClientInfo != nil}
  /// Clears the value of `githubClientInfo`. Subsequent reads from it will return its default value.
  public mutating func clearGithubClientInfo() {self._githubClientInfo = nil}

  ///id of the github repository
  public var githubRepositoryID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _githubClientInfo: Cloud_Planton_Apis_V1_Integration_Github_Proxy_GithubClientInfo? = nil
}

///input for command to synchronize magic pipeline files on github
public struct Cloud_Planton_Apis_V1_Integration_Github_Proxy_SynchronizeGithubMagicPipelineFilesCommandInput {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///github client info required to lookup template repo on github
  public var githubClientInfo: Cloud_Planton_Apis_V1_Integration_Github_Proxy_GithubClientInfo {
    get {return _githubClientInfo ?? Cloud_Planton_Apis_V1_Integration_Github_Proxy_GithubClientInfo()}
    set {_githubClientInfo = newValue}
  }
  /// Returns true if `githubClientInfo` has been explicitly set.
  public var hasGithubClientInfo: Bool {return self._githubClientInfo != nil}
  /// Clears the value of `githubClientInfo`. Subsequent reads from it will return its default value.
  public mutating func clearGithubClientInfo() {self._githubClientInfo = nil}

  ///id of the github repository to which the files are to be added
  public var githubRepositoryID: String = String()

  ///prefix to be used for identifying the existing magic pipelines to be deleted before adding new files
  public var magicPipelineFilesPrefix: String = String()

  ///files to be added to the repository
  public var magicPipelineFiles: [Cloud_Planton_Apis_V1_Code2cloud_Develop_Sourcecode_Project_Rpc_CodeProjectFile] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _githubClientInfo: Cloud_Planton_Apis_V1_Integration_Github_Proxy_GithubClientInfo? = nil
}

#if swift(>=5.5) && canImport(_Concurrency)
extension Cloud_Planton_Apis_V1_Integration_Github_Proxy_GithubClientInfo: @unchecked Sendable {}
extension Cloud_Planton_Apis_V1_Integration_Github_Proxy_GithubAppInstallation: @unchecked Sendable {}
extension Cloud_Planton_Apis_V1_Integration_Github_Proxy_ListRepositoriesQueryInput: @unchecked Sendable {}
extension Cloud_Planton_Apis_V1_Integration_Github_Proxy_GetRepositoryQueryInput: @unchecked Sendable {}
extension Cloud_Planton_Apis_V1_Integration_Github_Proxy_CreRepositoryCommandInput: @unchecked Sendable {}
extension Cloud_Planton_Apis_V1_Integration_Github_Proxy_GithubApplyTemplateCommandInput: @unchecked Sendable {}
extension Cloud_Planton_Apis_V1_Integration_Github_Proxy_AddSecretsToRepoCommandInput: @unchecked Sendable {}
extension Cloud_Planton_Apis_V1_Integration_Github_Proxy_AddSecretsToOrgCommandInput: @unchecked Sendable {}
extension Cloud_Planton_Apis_V1_Integration_Github_Proxy_GetGithubCodeProjectProfileQueryInput: @unchecked Sendable {}
extension Cloud_Planton_Apis_V1_Integration_Github_Proxy_SynchronizeGithubMagicPipelineFilesCommandInput: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "cloud.planton.apis.v1.integration.github.proxy"

extension Cloud_Planton_Apis_V1_Integration_Github_Proxy_GithubClientInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GithubClientInfo"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "github_host"),
    2: .standard(proto: "authorization_type"),
    3: .standard(proto: "api_token"),
    4: .standard(proto: "github_app_installation"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.githubHost) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.authorizationType) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.apiToken) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._githubAppInstallation) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.githubHost.isEmpty {
      try visitor.visitSingularStringField(value: self.githubHost, fieldNumber: 1)
    }
    if self.authorizationType != .unspecified {
      try visitor.visitSingularEnumField(value: self.authorizationType, fieldNumber: 2)
    }
    if !self.apiToken.isEmpty {
      try visitor.visitSingularStringField(value: self.apiToken, fieldNumber: 3)
    }
    try { if let v = self._githubAppInstallation {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Cloud_Planton_Apis_V1_Integration_Github_Proxy_GithubClientInfo, rhs: Cloud_Planton_Apis_V1_Integration_Github_Proxy_GithubClientInfo) -> Bool {
    if lhs.githubHost != rhs.githubHost {return false}
    if lhs.authorizationType != rhs.authorizationType {return false}
    if lhs.apiToken != rhs.apiToken {return false}
    if lhs._githubAppInstallation != rhs._githubAppInstallation {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cloud_Planton_Apis_V1_Integration_Github_Proxy_GithubAppInstallation: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GithubAppInstallation"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "github_app_id"),
    2: .standard(proto: "github_app_private_key_base64"),
    3: .standard(proto: "github_app_install_id"),
    4: .standard(proto: "install_owner_type"),
    5: .standard(proto: "github_app_installation_owner_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.githubAppID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.githubAppPrivateKeyBase64) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.githubAppInstallID) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self.installOwnerType) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.githubAppInstallationOwnerID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.githubAppID != 0 {
      try visitor.visitSingularInt64Field(value: self.githubAppID, fieldNumber: 1)
    }
    if !self.githubAppPrivateKeyBase64.isEmpty {
      try visitor.visitSingularStringField(value: self.githubAppPrivateKeyBase64, fieldNumber: 2)
    }
    if self.githubAppInstallID != 0 {
      try visitor.visitSingularInt64Field(value: self.githubAppInstallID, fieldNumber: 3)
    }
    if self.installOwnerType != .githubAppInstallationOwnerTypeUnspecified {
      try visitor.visitSingularEnumField(value: self.installOwnerType, fieldNumber: 4)
    }
    if !self.githubAppInstallationOwnerID.isEmpty {
      try visitor.visitSingularStringField(value: self.githubAppInstallationOwnerID, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Cloud_Planton_Apis_V1_Integration_Github_Proxy_GithubAppInstallation, rhs: Cloud_Planton_Apis_V1_Integration_Github_Proxy_GithubAppInstallation) -> Bool {
    if lhs.githubAppID != rhs.githubAppID {return false}
    if lhs.githubAppPrivateKeyBase64 != rhs.githubAppPrivateKeyBase64 {return false}
    if lhs.githubAppInstallID != rhs.githubAppInstallID {return false}
    if lhs.installOwnerType != rhs.installOwnerType {return false}
    if lhs.githubAppInstallationOwnerID != rhs.githubAppInstallationOwnerID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cloud_Planton_Apis_V1_Integration_Github_Proxy_ListRepositoriesQueryInput: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListRepositoriesQueryInput"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "github_client_info"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._githubClientInfo) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._githubClientInfo {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Cloud_Planton_Apis_V1_Integration_Github_Proxy_ListRepositoriesQueryInput, rhs: Cloud_Planton_Apis_V1_Integration_Github_Proxy_ListRepositoriesQueryInput) -> Bool {
    if lhs._githubClientInfo != rhs._githubClientInfo {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cloud_Planton_Apis_V1_Integration_Github_Proxy_GetRepositoryQueryInput: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetRepositoryQueryInput"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "github_client_info"),
    2: .standard(proto: "repository_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._githubClientInfo) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.repositoryID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._githubClientInfo {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.repositoryID.isEmpty {
      try visitor.visitSingularStringField(value: self.repositoryID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Cloud_Planton_Apis_V1_Integration_Github_Proxy_GetRepositoryQueryInput, rhs: Cloud_Planton_Apis_V1_Integration_Github_Proxy_GetRepositoryQueryInput) -> Bool {
    if lhs._githubClientInfo != rhs._githubClientInfo {return false}
    if lhs.repositoryID != rhs.repositoryID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cloud_Planton_Apis_V1_Integration_Github_Proxy_CreRepositoryCommandInput: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CreRepositoryCommandInput"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "github_client_info"),
    2: .standard(proto: "repository_name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._githubClientInfo) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.repositoryName) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._githubClientInfo {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.repositoryName.isEmpty {
      try visitor.visitSingularStringField(value: self.repositoryName, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Cloud_Planton_Apis_V1_Integration_Github_Proxy_CreRepositoryCommandInput, rhs: Cloud_Planton_Apis_V1_Integration_Github_Proxy_CreRepositoryCommandInput) -> Bool {
    if lhs._githubClientInfo != rhs._githubClientInfo {return false}
    if lhs.repositoryName != rhs.repositoryName {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cloud_Planton_Apis_V1_Integration_Github_Proxy_GithubApplyTemplateCommandInput: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GithubApplyTemplateCommandInput"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "template_project_github_client_info"),
    2: .standard(proto: "target_project_github_client_info"),
    3: .standard(proto: "template_project"),
    4: .standard(proto: "target_code_project"),
  ]

  fileprivate class _StorageClass {
    var _templateProjectGithubClientInfo: Cloud_Planton_Apis_V1_Integration_Github_Proxy_GithubClientInfo? = nil
    var _targetProjectGithubClientInfo: Cloud_Planton_Apis_V1_Integration_Github_Proxy_GithubClientInfo? = nil
    var _templateProject: Cloud_Planton_Apis_V1_Code2cloud_Develop_Sourcecode_Project_Rpc_CodeProject? = nil
    var _targetCodeProject: Cloud_Planton_Apis_V1_Code2cloud_Develop_Sourcecode_Project_Rpc_CodeProject? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _templateProjectGithubClientInfo = source._templateProjectGithubClientInfo
      _targetProjectGithubClientInfo = source._targetProjectGithubClientInfo
      _templateProject = source._templateProject
      _targetCodeProject = source._targetCodeProject
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._templateProjectGithubClientInfo) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._targetProjectGithubClientInfo) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._templateProject) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._targetCodeProject) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._templateProjectGithubClientInfo {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._targetProjectGithubClientInfo {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._templateProject {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._targetCodeProject {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Cloud_Planton_Apis_V1_Integration_Github_Proxy_GithubApplyTemplateCommandInput, rhs: Cloud_Planton_Apis_V1_Integration_Github_Proxy_GithubApplyTemplateCommandInput) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._templateProjectGithubClientInfo != rhs_storage._templateProjectGithubClientInfo {return false}
        if _storage._targetProjectGithubClientInfo != rhs_storage._targetProjectGithubClientInfo {return false}
        if _storage._templateProject != rhs_storage._templateProject {return false}
        if _storage._targetCodeProject != rhs_storage._targetCodeProject {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cloud_Planton_Apis_V1_Integration_Github_Proxy_AddSecretsToRepoCommandInput: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AddSecretsToRepoCommandInput"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "github_client_info"),
    2: .standard(proto: "github_repository_id"),
    3: .same(proto: "secrets"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._githubClientInfo) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.githubRepositoryID) }()
      case 3: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &self.secrets) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._githubClientInfo {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.githubRepositoryID.isEmpty {
      try visitor.visitSingularStringField(value: self.githubRepositoryID, fieldNumber: 2)
    }
    if !self.secrets.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: self.secrets, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Cloud_Planton_Apis_V1_Integration_Github_Proxy_AddSecretsToRepoCommandInput, rhs: Cloud_Planton_Apis_V1_Integration_Github_Proxy_AddSecretsToRepoCommandInput) -> Bool {
    if lhs._githubClientInfo != rhs._githubClientInfo {return false}
    if lhs.githubRepositoryID != rhs.githubRepositoryID {return false}
    if lhs.secrets != rhs.secrets {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cloud_Planton_Apis_V1_Integration_Github_Proxy_AddSecretsToOrgCommandInput: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AddSecretsToOrgCommandInput"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "github_client_info"),
    2: .standard(proto: "github_org_id"),
    3: .same(proto: "secrets"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._githubClientInfo) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.githubOrgID) }()
      case 3: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &self.secrets) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._githubClientInfo {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.githubOrgID.isEmpty {
      try visitor.visitSingularStringField(value: self.githubOrgID, fieldNumber: 2)
    }
    if !self.secrets.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: self.secrets, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Cloud_Planton_Apis_V1_Integration_Github_Proxy_AddSecretsToOrgCommandInput, rhs: Cloud_Planton_Apis_V1_Integration_Github_Proxy_AddSecretsToOrgCommandInput) -> Bool {
    if lhs._githubClientInfo != rhs._githubClientInfo {return false}
    if lhs.githubOrgID != rhs.githubOrgID {return false}
    if lhs.secrets != rhs.secrets {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cloud_Planton_Apis_V1_Integration_Github_Proxy_GetGithubCodeProjectProfileQueryInput: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetGithubCodeProjectProfileQueryInput"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "github_client_info"),
    2: .standard(proto: "github_repository_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._githubClientInfo) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.githubRepositoryID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._githubClientInfo {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.githubRepositoryID.isEmpty {
      try visitor.visitSingularStringField(value: self.githubRepositoryID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Cloud_Planton_Apis_V1_Integration_Github_Proxy_GetGithubCodeProjectProfileQueryInput, rhs: Cloud_Planton_Apis_V1_Integration_Github_Proxy_GetGithubCodeProjectProfileQueryInput) -> Bool {
    if lhs._githubClientInfo != rhs._githubClientInfo {return false}
    if lhs.githubRepositoryID != rhs.githubRepositoryID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cloud_Planton_Apis_V1_Integration_Github_Proxy_SynchronizeGithubMagicPipelineFilesCommandInput: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SynchronizeGithubMagicPipelineFilesCommandInput"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "github_client_info"),
    2: .standard(proto: "github_repository_id"),
    3: .standard(proto: "magic_pipeline_files_prefix"),
    4: .standard(proto: "magic_pipeline_files"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._githubClientInfo) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.githubRepositoryID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.magicPipelineFilesPrefix) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.magicPipelineFiles) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._githubClientInfo {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.githubRepositoryID.isEmpty {
      try visitor.visitSingularStringField(value: self.githubRepositoryID, fieldNumber: 2)
    }
    if !self.magicPipelineFilesPrefix.isEmpty {
      try visitor.visitSingularStringField(value: self.magicPipelineFilesPrefix, fieldNumber: 3)
    }
    if !self.magicPipelineFiles.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.magicPipelineFiles, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Cloud_Planton_Apis_V1_Integration_Github_Proxy_SynchronizeGithubMagicPipelineFilesCommandInput, rhs: Cloud_Planton_Apis_V1_Integration_Github_Proxy_SynchronizeGithubMagicPipelineFilesCommandInput) -> Bool {
    if lhs._githubClientInfo != rhs._githubClientInfo {return false}
    if lhs.githubRepositoryID != rhs.githubRepositoryID {return false}
    if lhs.magicPipelineFilesPrefix != rhs.magicPipelineFilesPrefix {return false}
    if lhs.magicPipelineFiles != rhs.magicPipelineFiles {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
