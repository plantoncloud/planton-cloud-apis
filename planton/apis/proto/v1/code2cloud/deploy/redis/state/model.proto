syntax = "proto3";

package planton.apis.proto.v1.code2cloud.deploy.opensource.redis.state;

import "planton/apis/proto/v1/commons/audit/model.proto";
import "planton/apis/proto/v1/commons/kubernetes/model.proto";
import "planton/apis/proto/v1/commons/resource/model.proto";
import "planton/apis/proto/v1/commons/resource/options/resource_options.proto";
import "planton/apis/proto/v1/stack/state/model.proto";
import "planton/apis/proto/v1/code2cloud/deploy/redis/state/enums/enums.proto";
import "planton/apis/proto/v1/commons/resource/owner/model.proto";

//redis-cluster state
message RedisClusterState {
  option (planton.apis.proto.v1.commons.resource.options.resource_type) = redis_cluster;
  option (planton.apis.proto.v1.commons.resource.options.is_runnable) = true;
  option (planton.apis.proto.v1.commons.resource.options.owner).type = environment;
  option (planton.apis.proto.v1.commons.resource.options.owner).id_field_path = "spec.owner.environment_id";

  //event-type
  planton.apis.proto.v1.code2cloud.deploy.opensource.redis.state.enums.RedisClusterEventType event_type = 99;

  //resource api version
  string api_version = 1;

  //resource kind
  string kind = 2;

  //resource metadata
  planton.apis.proto.v1.commons.resource.Metadata metadata = 3;

  //spec
  RedisClusterSpecState spec = 4;

  //status
  RedisClusterStatusState status = 5;
}

//redis-cluster spec
message RedisClusterSpecState {
  //resource parent
  planton.apis.proto.v1.commons.resource.owner.EnvironmentResourceOwner owner = 1;

  //kubernetes spec
  RedisClusterSpecKubernetesSpecState kubernetes = 2;
}

//redis-cluster status.
message RedisClusterStatusState {
  // resource lifecycle
  planton.apis.proto.v1.commons.resource.RunnableResourceLifecycle lifecycle = 99;

  // system audit info
  planton.apis.proto.v1.commons.audit.SysAudit sys_audit = 98;

  // stack-job
  planton.apis.proto.v1.stack.state.StackJobState stack_job = 97;

  //kubernetes status
  RedisClusterStatusKubernetesStatusState kubernetes = 1;
}

// redis-cluster kubernetes spec
message RedisClusterSpecKubernetesSpecState {
  //redis-container spec
  RedisClusterSpecKubernetesSpecRedisContainerSpecState redis_container = 1;

  //redis-cluster ingress-spec
  RedisClusterSpecKubernetesSpecIngressSpecState ingress = 2;
}

// redis-cluster kubernetes redis-container spec
message RedisClusterSpecKubernetesSpecRedisContainerSpecState {
  //number of redis pods.
  //recommended default 1
  int32 replicas = 1;

  //redis container cpu and memory resources.
  //recommended default "cpu-requests: 50m, memory-requests: 256Mi, cpu-limits: 1, memory-limits: 1Gi"
  planton.apis.proto.v1.commons.kubernetes.ContainerResources resources = 2;

  //flag to toggle persistence for redis data.
  //when enabled, redis in-memory data will be persisted to a storage volume.
  //the backup data from persistent volume is restored into redis memory between pod restarts.
  //defaults to false.
  bool is_persistence_enabled = 3;

  //size of persistent volume attached to each redis pod
  //if the client does not provide a value, the default value is configured.
  //this attribute is ignored when persistence is not enabled.
  //this persistent volume is used for backing up in-memory data.
  //data from the persistent volume will be restored into memory between pod restarts.
  //this value can not be modified as kubernetes does not allow updating the stateful-set specification after creation.
  string disk_size = 4;
}

// redis-cluster kubernetes ingress spec
message RedisClusterSpecKubernetesSpecIngressSpecState {
  //standard-endpoint domain to be used for creating internal and external endpoints for redis-cluster.
  //only tls enabled standard-endpoints are eligible for creating redis endpoints.
  string standard_endpoint_id = 1;

  //endpoint-domain-name used for creating redis-cluster endpoints.
  //value is computed from the configured standard-endpoint.
  string endpoint_domain_name = 2;
}

//redis-cluster kubernetes status
message RedisClusterStatusKubernetesStatusState {
  //kubernetes namespace in which redis-cluster is created.
  string namespace = 1;

  //kubernetes service name for redis-cluster.
  //ex: main-redis-cluster
  //in the above example, "main" is the name of the redis-cluster
  string service = 2;

  //command to setup port-forwarding to open redis-cluster from developers laptop.
  //this might come handy when redis-cluster ingress is disabled for security reasons.
  //this is rendered by combining redis_cluster_kubernetes_service and kubernetes_namespace
  //ex: kubectl port-forward svc/redis_cluster_kubernetes_service -n kubernetes_namespace 6379:6379
  //running the command from this attribute makes it possible to access redis-cluster using http://localhost:8080/redis
  string port_forward_command = 3;

  //kubernetes endpoint to connect to redis-cluster from the web browser.
  //ex: main-redis-cluster.namespace.svc.cluster.local:6379
  string kube_endpoint = 4;

  //public endpoint to open redis-cluster from clients outside kubernetes.
  //ex: https://rdc-planton-pcs-dev-main.data.dev.planton.live:6379/redis
  string ingress_endpoint = 5;
}
