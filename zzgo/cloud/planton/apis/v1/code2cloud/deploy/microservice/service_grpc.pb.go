// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.3.0
// - protoc             (unknown)
// source: cloud/planton/apis/v1/code2cloud/deploy/microservice/service.proto

package microservice

import (
	context "context"
	kubecluster "github.com/plantoncloud/planton-cloud-apis/zzgo/cloud/planton/apis/v1/code2cloud/deploy/kubecluster"
	project "github.com/plantoncloud/planton-cloud-apis/zzgo/cloud/planton/apis/v1/code2cloud/develop/sourcecode/project"
	environment "github.com/plantoncloud/planton-cloud-apis/zzgo/cloud/planton/apis/v1/code2cloud/environment"
	stream "github.com/plantoncloud/planton-cloud-apis/zzgo/cloud/planton/apis/v1/commons/grpc/stream"
	pagination "github.com/plantoncloud/planton-cloud-apis/zzgo/cloud/planton/apis/v1/commons/rpc/pagination"
	resource "github.com/plantoncloud/planton-cloud-apis/zzgo/cloud/planton/apis/v1/integration/kubernetes/resource"
	product "github.com/plantoncloud/planton-cloud-apis/zzgo/cloud/planton/apis/v1/resourcemanager/product"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

const (
	MicroserviceInstanceCommandController_Create_FullMethodName  = "/cloud.planton.apis.v1.code2cloud.deploy.microservice.MicroserviceInstanceCommandController/create"
	MicroserviceInstanceCommandController_Update_FullMethodName  = "/cloud.planton.apis.v1.code2cloud.deploy.microservice.MicroserviceInstanceCommandController/update"
	MicroserviceInstanceCommandController_Delete_FullMethodName  = "/cloud.planton.apis.v1.code2cloud.deploy.microservice.MicroserviceInstanceCommandController/delete"
	MicroserviceInstanceCommandController_Restore_FullMethodName = "/cloud.planton.apis.v1.code2cloud.deploy.microservice.MicroserviceInstanceCommandController/restore"
	MicroserviceInstanceCommandController_Restart_FullMethodName = "/cloud.planton.apis.v1.code2cloud.deploy.microservice.MicroserviceInstanceCommandController/restart"
	MicroserviceInstanceCommandController_Pause_FullMethodName   = "/cloud.planton.apis.v1.code2cloud.deploy.microservice.MicroserviceInstanceCommandController/pause"
	MicroserviceInstanceCommandController_Unpause_FullMethodName = "/cloud.planton.apis.v1.code2cloud.deploy.microservice.MicroserviceInstanceCommandController/unpause"
)

// MicroserviceInstanceCommandControllerClient is the client API for MicroserviceInstanceCommandController service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type MicroserviceInstanceCommandControllerClient interface {
	// create microservice-instance
	Create(ctx context.Context, in *MicroserviceInstance, opts ...grpc.CallOption) (*MicroserviceInstance, error)
	// update microservice-instance
	Update(ctx context.Context, in *MicroserviceInstance, opts ...grpc.CallOption) (*MicroserviceInstance, error)
	// delete microservice-instance
	Delete(ctx context.Context, in *MicroserviceInstanceId, opts ...grpc.CallOption) (*MicroserviceInstance, error)
	// restore a deleted microservice-instance of a environment.
	Restore(ctx context.Context, in *MicroserviceInstance, opts ...grpc.CallOption) (*MicroserviceInstance, error)
	// restart a microservice-instance running in a environment.
	// microservice-instance is restarted by deleting running pods which will be automatically recreated by kubernetes.
	Restart(ctx context.Context, in *MicroserviceInstanceId, opts ...grpc.CallOption) (*MicroserviceInstance, error)
	// pause a microservice-instance running in a environment.
	// microservice-instance is paused by scaling down number of replicas of
	// the kubernetes deployment/stateful sets to zero in the environment.
	Pause(ctx context.Context, in *MicroserviceInstanceId, opts ...grpc.CallOption) (*MicroserviceInstance, error)
	// unpause a previously paused microservice-instance running in a environment.
	// unpause is done by scaling the number of pods back to the number of
	// replicas configured for the microservice-instance.
	Unpause(ctx context.Context, in *MicroserviceInstanceId, opts ...grpc.CallOption) (*MicroserviceInstance, error)
}

type microserviceInstanceCommandControllerClient struct {
	cc grpc.ClientConnInterface
}

func NewMicroserviceInstanceCommandControllerClient(cc grpc.ClientConnInterface) MicroserviceInstanceCommandControllerClient {
	return &microserviceInstanceCommandControllerClient{cc}
}

func (c *microserviceInstanceCommandControllerClient) Create(ctx context.Context, in *MicroserviceInstance, opts ...grpc.CallOption) (*MicroserviceInstance, error) {
	out := new(MicroserviceInstance)
	err := c.cc.Invoke(ctx, MicroserviceInstanceCommandController_Create_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *microserviceInstanceCommandControllerClient) Update(ctx context.Context, in *MicroserviceInstance, opts ...grpc.CallOption) (*MicroserviceInstance, error) {
	out := new(MicroserviceInstance)
	err := c.cc.Invoke(ctx, MicroserviceInstanceCommandController_Update_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *microserviceInstanceCommandControllerClient) Delete(ctx context.Context, in *MicroserviceInstanceId, opts ...grpc.CallOption) (*MicroserviceInstance, error) {
	out := new(MicroserviceInstance)
	err := c.cc.Invoke(ctx, MicroserviceInstanceCommandController_Delete_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *microserviceInstanceCommandControllerClient) Restore(ctx context.Context, in *MicroserviceInstance, opts ...grpc.CallOption) (*MicroserviceInstance, error) {
	out := new(MicroserviceInstance)
	err := c.cc.Invoke(ctx, MicroserviceInstanceCommandController_Restore_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *microserviceInstanceCommandControllerClient) Restart(ctx context.Context, in *MicroserviceInstanceId, opts ...grpc.CallOption) (*MicroserviceInstance, error) {
	out := new(MicroserviceInstance)
	err := c.cc.Invoke(ctx, MicroserviceInstanceCommandController_Restart_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *microserviceInstanceCommandControllerClient) Pause(ctx context.Context, in *MicroserviceInstanceId, opts ...grpc.CallOption) (*MicroserviceInstance, error) {
	out := new(MicroserviceInstance)
	err := c.cc.Invoke(ctx, MicroserviceInstanceCommandController_Pause_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *microserviceInstanceCommandControllerClient) Unpause(ctx context.Context, in *MicroserviceInstanceId, opts ...grpc.CallOption) (*MicroserviceInstance, error) {
	out := new(MicroserviceInstance)
	err := c.cc.Invoke(ctx, MicroserviceInstanceCommandController_Unpause_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// MicroserviceInstanceCommandControllerServer is the server API for MicroserviceInstanceCommandController service.
// All implementations should embed UnimplementedMicroserviceInstanceCommandControllerServer
// for forward compatibility
type MicroserviceInstanceCommandControllerServer interface {
	// create microservice-instance
	Create(context.Context, *MicroserviceInstance) (*MicroserviceInstance, error)
	// update microservice-instance
	Update(context.Context, *MicroserviceInstance) (*MicroserviceInstance, error)
	// delete microservice-instance
	Delete(context.Context, *MicroserviceInstanceId) (*MicroserviceInstance, error)
	// restore a deleted microservice-instance of a environment.
	Restore(context.Context, *MicroserviceInstance) (*MicroserviceInstance, error)
	// restart a microservice-instance running in a environment.
	// microservice-instance is restarted by deleting running pods which will be automatically recreated by kubernetes.
	Restart(context.Context, *MicroserviceInstanceId) (*MicroserviceInstance, error)
	// pause a microservice-instance running in a environment.
	// microservice-instance is paused by scaling down number of replicas of
	// the kubernetes deployment/stateful sets to zero in the environment.
	Pause(context.Context, *MicroserviceInstanceId) (*MicroserviceInstance, error)
	// unpause a previously paused microservice-instance running in a environment.
	// unpause is done by scaling the number of pods back to the number of
	// replicas configured for the microservice-instance.
	Unpause(context.Context, *MicroserviceInstanceId) (*MicroserviceInstance, error)
}

// UnimplementedMicroserviceInstanceCommandControllerServer should be embedded to have forward compatible implementations.
type UnimplementedMicroserviceInstanceCommandControllerServer struct {
}

func (UnimplementedMicroserviceInstanceCommandControllerServer) Create(context.Context, *MicroserviceInstance) (*MicroserviceInstance, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Create not implemented")
}
func (UnimplementedMicroserviceInstanceCommandControllerServer) Update(context.Context, *MicroserviceInstance) (*MicroserviceInstance, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Update not implemented")
}
func (UnimplementedMicroserviceInstanceCommandControllerServer) Delete(context.Context, *MicroserviceInstanceId) (*MicroserviceInstance, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Delete not implemented")
}
func (UnimplementedMicroserviceInstanceCommandControllerServer) Restore(context.Context, *MicroserviceInstance) (*MicroserviceInstance, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Restore not implemented")
}
func (UnimplementedMicroserviceInstanceCommandControllerServer) Restart(context.Context, *MicroserviceInstanceId) (*MicroserviceInstance, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Restart not implemented")
}
func (UnimplementedMicroserviceInstanceCommandControllerServer) Pause(context.Context, *MicroserviceInstanceId) (*MicroserviceInstance, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Pause not implemented")
}
func (UnimplementedMicroserviceInstanceCommandControllerServer) Unpause(context.Context, *MicroserviceInstanceId) (*MicroserviceInstance, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Unpause not implemented")
}

// UnsafeMicroserviceInstanceCommandControllerServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to MicroserviceInstanceCommandControllerServer will
// result in compilation errors.
type UnsafeMicroserviceInstanceCommandControllerServer interface {
	mustEmbedUnimplementedMicroserviceInstanceCommandControllerServer()
}

func RegisterMicroserviceInstanceCommandControllerServer(s grpc.ServiceRegistrar, srv MicroserviceInstanceCommandControllerServer) {
	s.RegisterService(&MicroserviceInstanceCommandController_ServiceDesc, srv)
}

func _MicroserviceInstanceCommandController_Create_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MicroserviceInstance)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MicroserviceInstanceCommandControllerServer).Create(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MicroserviceInstanceCommandController_Create_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MicroserviceInstanceCommandControllerServer).Create(ctx, req.(*MicroserviceInstance))
	}
	return interceptor(ctx, in, info, handler)
}

func _MicroserviceInstanceCommandController_Update_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MicroserviceInstance)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MicroserviceInstanceCommandControllerServer).Update(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MicroserviceInstanceCommandController_Update_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MicroserviceInstanceCommandControllerServer).Update(ctx, req.(*MicroserviceInstance))
	}
	return interceptor(ctx, in, info, handler)
}

func _MicroserviceInstanceCommandController_Delete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MicroserviceInstanceId)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MicroserviceInstanceCommandControllerServer).Delete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MicroserviceInstanceCommandController_Delete_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MicroserviceInstanceCommandControllerServer).Delete(ctx, req.(*MicroserviceInstanceId))
	}
	return interceptor(ctx, in, info, handler)
}

func _MicroserviceInstanceCommandController_Restore_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MicroserviceInstance)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MicroserviceInstanceCommandControllerServer).Restore(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MicroserviceInstanceCommandController_Restore_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MicroserviceInstanceCommandControllerServer).Restore(ctx, req.(*MicroserviceInstance))
	}
	return interceptor(ctx, in, info, handler)
}

func _MicroserviceInstanceCommandController_Restart_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MicroserviceInstanceId)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MicroserviceInstanceCommandControllerServer).Restart(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MicroserviceInstanceCommandController_Restart_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MicroserviceInstanceCommandControllerServer).Restart(ctx, req.(*MicroserviceInstanceId))
	}
	return interceptor(ctx, in, info, handler)
}

func _MicroserviceInstanceCommandController_Pause_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MicroserviceInstanceId)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MicroserviceInstanceCommandControllerServer).Pause(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MicroserviceInstanceCommandController_Pause_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MicroserviceInstanceCommandControllerServer).Pause(ctx, req.(*MicroserviceInstanceId))
	}
	return interceptor(ctx, in, info, handler)
}

func _MicroserviceInstanceCommandController_Unpause_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MicroserviceInstanceId)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MicroserviceInstanceCommandControllerServer).Unpause(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MicroserviceInstanceCommandController_Unpause_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MicroserviceInstanceCommandControllerServer).Unpause(ctx, req.(*MicroserviceInstanceId))
	}
	return interceptor(ctx, in, info, handler)
}

// MicroserviceInstanceCommandController_ServiceDesc is the grpc.ServiceDesc for MicroserviceInstanceCommandController service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var MicroserviceInstanceCommandController_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "cloud.planton.apis.v1.code2cloud.deploy.microservice.MicroserviceInstanceCommandController",
	HandlerType: (*MicroserviceInstanceCommandControllerServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "create",
			Handler:    _MicroserviceInstanceCommandController_Create_Handler,
		},
		{
			MethodName: "update",
			Handler:    _MicroserviceInstanceCommandController_Update_Handler,
		},
		{
			MethodName: "delete",
			Handler:    _MicroserviceInstanceCommandController_Delete_Handler,
		},
		{
			MethodName: "restore",
			Handler:    _MicroserviceInstanceCommandController_Restore_Handler,
		},
		{
			MethodName: "restart",
			Handler:    _MicroserviceInstanceCommandController_Restart_Handler,
		},
		{
			MethodName: "pause",
			Handler:    _MicroserviceInstanceCommandController_Pause_Handler,
		},
		{
			MethodName: "unpause",
			Handler:    _MicroserviceInstanceCommandController_Unpause_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "cloud/planton/apis/v1/code2cloud/deploy/microservice/service.proto",
}

const (
	MicroserviceInstanceQueryController_List_FullMethodName                               = "/cloud.planton.apis.v1.code2cloud.deploy.microservice.MicroserviceInstanceQueryController/list"
	MicroserviceInstanceQueryController_GetById_FullMethodName                            = "/cloud.planton.apis.v1.code2cloud.deploy.microservice.MicroserviceInstanceQueryController/getById"
	MicroserviceInstanceQueryController_FindByProductId_FullMethodName                    = "/cloud.planton.apis.v1.code2cloud.deploy.microservice.MicroserviceInstanceQueryController/findByProductId"
	MicroserviceInstanceQueryController_FindByEnvironmentId_FullMethodName                = "/cloud.planton.apis.v1.code2cloud.deploy.microservice.MicroserviceInstanceQueryController/findByEnvironmentId"
	MicroserviceInstanceQueryController_FindByKubeClusterId_FullMethodName                = "/cloud.planton.apis.v1.code2cloud.deploy.microservice.MicroserviceInstanceQueryController/findByKubeClusterId"
	MicroserviceInstanceQueryController_FindByEnvironmentIdByCodeProjectId_FullMethodName = "/cloud.planton.apis.v1.code2cloud.deploy.microservice.MicroserviceInstanceQueryController/findByEnvironmentIdByCodeProjectId"
	MicroserviceInstanceQueryController_FindPods_FullMethodName                           = "/cloud.planton.apis.v1.code2cloud.deploy.microservice.MicroserviceInstanceQueryController/findPods"
	MicroserviceInstanceQueryController_GetLogStream_FullMethodName                       = "/cloud.planton.apis.v1.code2cloud.deploy.microservice.MicroserviceInstanceQueryController/getLogStream"
	MicroserviceInstanceQueryController_GetByCodeProjectId_FullMethodName                 = "/cloud.planton.apis.v1.code2cloud.deploy.microservice.MicroserviceInstanceQueryController/getByCodeProjectId"
	MicroserviceInstanceQueryController_FindByCodeProjectUrl_FullMethodName               = "/cloud.planton.apis.v1.code2cloud.deploy.microservice.MicroserviceInstanceQueryController/findByCodeProjectUrl"
	MicroserviceInstanceQueryController_GetEnvVarMap_FullMethodName                       = "/cloud.planton.apis.v1.code2cloud.deploy.microservice.MicroserviceInstanceQueryController/getEnvVarMap"
)

// MicroserviceInstanceQueryControllerClient is the client API for MicroserviceInstanceQueryController service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type MicroserviceInstanceQueryControllerClient interface {
	// list all microservice-instances on planton instance for the requested page. This is intended for use on portal.
	List(ctx context.Context, in *pagination.PageInfo, opts ...grpc.CallOption) (*MicroserviceInstanceList, error)
	// look up microservice-instance using microservice-instance id
	GetById(ctx context.Context, in *MicroserviceInstanceId, opts ...grpc.CallOption) (*MicroserviceInstance, error)
	// find microservice-instances by product id.
	// response contains only the resources that the authenticated user account has viewer access to.
	FindByProductId(ctx context.Context, in *product.ProductId, opts ...grpc.CallOption) (*MicroserviceInstances, error)
	// find microservice-instances by environment
	FindByEnvironmentId(ctx context.Context, in *environment.EnvironmentId, opts ...grpc.CallOption) (*MicroserviceInstances, error)
	// find microservice-instances by kube-cluster
	FindByKubeClusterId(ctx context.Context, in *kubecluster.KubeClusterId, opts ...grpc.CallOption) (*MicroserviceInstances, error)
	// find microservice-instances in a environment for a code-project
	FindByEnvironmentIdByCodeProjectId(ctx context.Context, in *ByEnvironmentIdByCodeProjectIdInput, opts ...grpc.CallOption) (*MicroserviceInstances, error)
	// lookup pods of a microservice-instance deployed to a environment
	FindPods(ctx context.Context, in *MicroserviceInstanceId, opts ...grpc.CallOption) (*resource.Pods, error)
	// get a log stream for a running instance of a microservice-instance
	GetLogStream(ctx context.Context, in *GetMicroserviceInstanceLogStreamQueryInput, opts ...grpc.CallOption) (MicroserviceInstanceQueryController_GetLogStreamClient, error)
	// lookup a microservice-instance by code project id
	GetByCodeProjectId(ctx context.Context, in *project.CodeProjectId, opts ...grpc.CallOption) (*MicroserviceInstance, error)
	// lookup all microservice-instances by code project url
	FindByCodeProjectUrl(ctx context.Context, in *project.CodeProjectUrl, opts ...grpc.CallOption) (*MicroserviceInstances, error)
	GetEnvVarMap(ctx context.Context, in *MicroserviceInstance, opts ...grpc.CallOption) (*MicroserviceInstanceEnvVarMap, error)
}

type microserviceInstanceQueryControllerClient struct {
	cc grpc.ClientConnInterface
}

func NewMicroserviceInstanceQueryControllerClient(cc grpc.ClientConnInterface) MicroserviceInstanceQueryControllerClient {
	return &microserviceInstanceQueryControllerClient{cc}
}

func (c *microserviceInstanceQueryControllerClient) List(ctx context.Context, in *pagination.PageInfo, opts ...grpc.CallOption) (*MicroserviceInstanceList, error) {
	out := new(MicroserviceInstanceList)
	err := c.cc.Invoke(ctx, MicroserviceInstanceQueryController_List_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *microserviceInstanceQueryControllerClient) GetById(ctx context.Context, in *MicroserviceInstanceId, opts ...grpc.CallOption) (*MicroserviceInstance, error) {
	out := new(MicroserviceInstance)
	err := c.cc.Invoke(ctx, MicroserviceInstanceQueryController_GetById_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *microserviceInstanceQueryControllerClient) FindByProductId(ctx context.Context, in *product.ProductId, opts ...grpc.CallOption) (*MicroserviceInstances, error) {
	out := new(MicroserviceInstances)
	err := c.cc.Invoke(ctx, MicroserviceInstanceQueryController_FindByProductId_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *microserviceInstanceQueryControllerClient) FindByEnvironmentId(ctx context.Context, in *environment.EnvironmentId, opts ...grpc.CallOption) (*MicroserviceInstances, error) {
	out := new(MicroserviceInstances)
	err := c.cc.Invoke(ctx, MicroserviceInstanceQueryController_FindByEnvironmentId_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *microserviceInstanceQueryControllerClient) FindByKubeClusterId(ctx context.Context, in *kubecluster.KubeClusterId, opts ...grpc.CallOption) (*MicroserviceInstances, error) {
	out := new(MicroserviceInstances)
	err := c.cc.Invoke(ctx, MicroserviceInstanceQueryController_FindByKubeClusterId_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *microserviceInstanceQueryControllerClient) FindByEnvironmentIdByCodeProjectId(ctx context.Context, in *ByEnvironmentIdByCodeProjectIdInput, opts ...grpc.CallOption) (*MicroserviceInstances, error) {
	out := new(MicroserviceInstances)
	err := c.cc.Invoke(ctx, MicroserviceInstanceQueryController_FindByEnvironmentIdByCodeProjectId_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *microserviceInstanceQueryControllerClient) FindPods(ctx context.Context, in *MicroserviceInstanceId, opts ...grpc.CallOption) (*resource.Pods, error) {
	out := new(resource.Pods)
	err := c.cc.Invoke(ctx, MicroserviceInstanceQueryController_FindPods_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *microserviceInstanceQueryControllerClient) GetLogStream(ctx context.Context, in *GetMicroserviceInstanceLogStreamQueryInput, opts ...grpc.CallOption) (MicroserviceInstanceQueryController_GetLogStreamClient, error) {
	stream, err := c.cc.NewStream(ctx, &MicroserviceInstanceQueryController_ServiceDesc.Streams[0], MicroserviceInstanceQueryController_GetLogStream_FullMethodName, opts...)
	if err != nil {
		return nil, err
	}
	x := &microserviceInstanceQueryControllerGetLogStreamClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type MicroserviceInstanceQueryController_GetLogStreamClient interface {
	Recv() (*stream.OutputLine, error)
	grpc.ClientStream
}

type microserviceInstanceQueryControllerGetLogStreamClient struct {
	grpc.ClientStream
}

func (x *microserviceInstanceQueryControllerGetLogStreamClient) Recv() (*stream.OutputLine, error) {
	m := new(stream.OutputLine)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *microserviceInstanceQueryControllerClient) GetByCodeProjectId(ctx context.Context, in *project.CodeProjectId, opts ...grpc.CallOption) (*MicroserviceInstance, error) {
	out := new(MicroserviceInstance)
	err := c.cc.Invoke(ctx, MicroserviceInstanceQueryController_GetByCodeProjectId_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *microserviceInstanceQueryControllerClient) FindByCodeProjectUrl(ctx context.Context, in *project.CodeProjectUrl, opts ...grpc.CallOption) (*MicroserviceInstances, error) {
	out := new(MicroserviceInstances)
	err := c.cc.Invoke(ctx, MicroserviceInstanceQueryController_FindByCodeProjectUrl_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *microserviceInstanceQueryControllerClient) GetEnvVarMap(ctx context.Context, in *MicroserviceInstance, opts ...grpc.CallOption) (*MicroserviceInstanceEnvVarMap, error) {
	out := new(MicroserviceInstanceEnvVarMap)
	err := c.cc.Invoke(ctx, MicroserviceInstanceQueryController_GetEnvVarMap_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// MicroserviceInstanceQueryControllerServer is the server API for MicroserviceInstanceQueryController service.
// All implementations should embed UnimplementedMicroserviceInstanceQueryControllerServer
// for forward compatibility
type MicroserviceInstanceQueryControllerServer interface {
	// list all microservice-instances on planton instance for the requested page. This is intended for use on portal.
	List(context.Context, *pagination.PageInfo) (*MicroserviceInstanceList, error)
	// look up microservice-instance using microservice-instance id
	GetById(context.Context, *MicroserviceInstanceId) (*MicroserviceInstance, error)
	// find microservice-instances by product id.
	// response contains only the resources that the authenticated user account has viewer access to.
	FindByProductId(context.Context, *product.ProductId) (*MicroserviceInstances, error)
	// find microservice-instances by environment
	FindByEnvironmentId(context.Context, *environment.EnvironmentId) (*MicroserviceInstances, error)
	// find microservice-instances by kube-cluster
	FindByKubeClusterId(context.Context, *kubecluster.KubeClusterId) (*MicroserviceInstances, error)
	// find microservice-instances in a environment for a code-project
	FindByEnvironmentIdByCodeProjectId(context.Context, *ByEnvironmentIdByCodeProjectIdInput) (*MicroserviceInstances, error)
	// lookup pods of a microservice-instance deployed to a environment
	FindPods(context.Context, *MicroserviceInstanceId) (*resource.Pods, error)
	// get a log stream for a running instance of a microservice-instance
	GetLogStream(*GetMicroserviceInstanceLogStreamQueryInput, MicroserviceInstanceQueryController_GetLogStreamServer) error
	// lookup a microservice-instance by code project id
	GetByCodeProjectId(context.Context, *project.CodeProjectId) (*MicroserviceInstance, error)
	// lookup all microservice-instances by code project url
	FindByCodeProjectUrl(context.Context, *project.CodeProjectUrl) (*MicroserviceInstances, error)
	GetEnvVarMap(context.Context, *MicroserviceInstance) (*MicroserviceInstanceEnvVarMap, error)
}

// UnimplementedMicroserviceInstanceQueryControllerServer should be embedded to have forward compatible implementations.
type UnimplementedMicroserviceInstanceQueryControllerServer struct {
}

func (UnimplementedMicroserviceInstanceQueryControllerServer) List(context.Context, *pagination.PageInfo) (*MicroserviceInstanceList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method List not implemented")
}
func (UnimplementedMicroserviceInstanceQueryControllerServer) GetById(context.Context, *MicroserviceInstanceId) (*MicroserviceInstance, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetById not implemented")
}
func (UnimplementedMicroserviceInstanceQueryControllerServer) FindByProductId(context.Context, *product.ProductId) (*MicroserviceInstances, error) {
	return nil, status.Errorf(codes.Unimplemented, "method FindByProductId not implemented")
}
func (UnimplementedMicroserviceInstanceQueryControllerServer) FindByEnvironmentId(context.Context, *environment.EnvironmentId) (*MicroserviceInstances, error) {
	return nil, status.Errorf(codes.Unimplemented, "method FindByEnvironmentId not implemented")
}
func (UnimplementedMicroserviceInstanceQueryControllerServer) FindByKubeClusterId(context.Context, *kubecluster.KubeClusterId) (*MicroserviceInstances, error) {
	return nil, status.Errorf(codes.Unimplemented, "method FindByKubeClusterId not implemented")
}
func (UnimplementedMicroserviceInstanceQueryControllerServer) FindByEnvironmentIdByCodeProjectId(context.Context, *ByEnvironmentIdByCodeProjectIdInput) (*MicroserviceInstances, error) {
	return nil, status.Errorf(codes.Unimplemented, "method FindByEnvironmentIdByCodeProjectId not implemented")
}
func (UnimplementedMicroserviceInstanceQueryControllerServer) FindPods(context.Context, *MicroserviceInstanceId) (*resource.Pods, error) {
	return nil, status.Errorf(codes.Unimplemented, "method FindPods not implemented")
}
func (UnimplementedMicroserviceInstanceQueryControllerServer) GetLogStream(*GetMicroserviceInstanceLogStreamQueryInput, MicroserviceInstanceQueryController_GetLogStreamServer) error {
	return status.Errorf(codes.Unimplemented, "method GetLogStream not implemented")
}
func (UnimplementedMicroserviceInstanceQueryControllerServer) GetByCodeProjectId(context.Context, *project.CodeProjectId) (*MicroserviceInstance, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetByCodeProjectId not implemented")
}
func (UnimplementedMicroserviceInstanceQueryControllerServer) FindByCodeProjectUrl(context.Context, *project.CodeProjectUrl) (*MicroserviceInstances, error) {
	return nil, status.Errorf(codes.Unimplemented, "method FindByCodeProjectUrl not implemented")
}
func (UnimplementedMicroserviceInstanceQueryControllerServer) GetEnvVarMap(context.Context, *MicroserviceInstance) (*MicroserviceInstanceEnvVarMap, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetEnvVarMap not implemented")
}

// UnsafeMicroserviceInstanceQueryControllerServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to MicroserviceInstanceQueryControllerServer will
// result in compilation errors.
type UnsafeMicroserviceInstanceQueryControllerServer interface {
	mustEmbedUnimplementedMicroserviceInstanceQueryControllerServer()
}

func RegisterMicroserviceInstanceQueryControllerServer(s grpc.ServiceRegistrar, srv MicroserviceInstanceQueryControllerServer) {
	s.RegisterService(&MicroserviceInstanceQueryController_ServiceDesc, srv)
}

func _MicroserviceInstanceQueryController_List_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(pagination.PageInfo)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MicroserviceInstanceQueryControllerServer).List(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MicroserviceInstanceQueryController_List_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MicroserviceInstanceQueryControllerServer).List(ctx, req.(*pagination.PageInfo))
	}
	return interceptor(ctx, in, info, handler)
}

func _MicroserviceInstanceQueryController_GetById_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MicroserviceInstanceId)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MicroserviceInstanceQueryControllerServer).GetById(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MicroserviceInstanceQueryController_GetById_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MicroserviceInstanceQueryControllerServer).GetById(ctx, req.(*MicroserviceInstanceId))
	}
	return interceptor(ctx, in, info, handler)
}

func _MicroserviceInstanceQueryController_FindByProductId_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(product.ProductId)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MicroserviceInstanceQueryControllerServer).FindByProductId(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MicroserviceInstanceQueryController_FindByProductId_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MicroserviceInstanceQueryControllerServer).FindByProductId(ctx, req.(*product.ProductId))
	}
	return interceptor(ctx, in, info, handler)
}

func _MicroserviceInstanceQueryController_FindByEnvironmentId_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(environment.EnvironmentId)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MicroserviceInstanceQueryControllerServer).FindByEnvironmentId(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MicroserviceInstanceQueryController_FindByEnvironmentId_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MicroserviceInstanceQueryControllerServer).FindByEnvironmentId(ctx, req.(*environment.EnvironmentId))
	}
	return interceptor(ctx, in, info, handler)
}

func _MicroserviceInstanceQueryController_FindByKubeClusterId_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(kubecluster.KubeClusterId)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MicroserviceInstanceQueryControllerServer).FindByKubeClusterId(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MicroserviceInstanceQueryController_FindByKubeClusterId_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MicroserviceInstanceQueryControllerServer).FindByKubeClusterId(ctx, req.(*kubecluster.KubeClusterId))
	}
	return interceptor(ctx, in, info, handler)
}

func _MicroserviceInstanceQueryController_FindByEnvironmentIdByCodeProjectId_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ByEnvironmentIdByCodeProjectIdInput)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MicroserviceInstanceQueryControllerServer).FindByEnvironmentIdByCodeProjectId(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MicroserviceInstanceQueryController_FindByEnvironmentIdByCodeProjectId_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MicroserviceInstanceQueryControllerServer).FindByEnvironmentIdByCodeProjectId(ctx, req.(*ByEnvironmentIdByCodeProjectIdInput))
	}
	return interceptor(ctx, in, info, handler)
}

func _MicroserviceInstanceQueryController_FindPods_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MicroserviceInstanceId)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MicroserviceInstanceQueryControllerServer).FindPods(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MicroserviceInstanceQueryController_FindPods_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MicroserviceInstanceQueryControllerServer).FindPods(ctx, req.(*MicroserviceInstanceId))
	}
	return interceptor(ctx, in, info, handler)
}

func _MicroserviceInstanceQueryController_GetLogStream_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(GetMicroserviceInstanceLogStreamQueryInput)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(MicroserviceInstanceQueryControllerServer).GetLogStream(m, &microserviceInstanceQueryControllerGetLogStreamServer{stream})
}

type MicroserviceInstanceQueryController_GetLogStreamServer interface {
	Send(*stream.OutputLine) error
	grpc.ServerStream
}

type microserviceInstanceQueryControllerGetLogStreamServer struct {
	grpc.ServerStream
}

func (x *microserviceInstanceQueryControllerGetLogStreamServer) Send(m *stream.OutputLine) error {
	return x.ServerStream.SendMsg(m)
}

func _MicroserviceInstanceQueryController_GetByCodeProjectId_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(project.CodeProjectId)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MicroserviceInstanceQueryControllerServer).GetByCodeProjectId(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MicroserviceInstanceQueryController_GetByCodeProjectId_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MicroserviceInstanceQueryControllerServer).GetByCodeProjectId(ctx, req.(*project.CodeProjectId))
	}
	return interceptor(ctx, in, info, handler)
}

func _MicroserviceInstanceQueryController_FindByCodeProjectUrl_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(project.CodeProjectUrl)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MicroserviceInstanceQueryControllerServer).FindByCodeProjectUrl(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MicroserviceInstanceQueryController_FindByCodeProjectUrl_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MicroserviceInstanceQueryControllerServer).FindByCodeProjectUrl(ctx, req.(*project.CodeProjectUrl))
	}
	return interceptor(ctx, in, info, handler)
}

func _MicroserviceInstanceQueryController_GetEnvVarMap_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MicroserviceInstance)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MicroserviceInstanceQueryControllerServer).GetEnvVarMap(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MicroserviceInstanceQueryController_GetEnvVarMap_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MicroserviceInstanceQueryControllerServer).GetEnvVarMap(ctx, req.(*MicroserviceInstance))
	}
	return interceptor(ctx, in, info, handler)
}

// MicroserviceInstanceQueryController_ServiceDesc is the grpc.ServiceDesc for MicroserviceInstanceQueryController service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var MicroserviceInstanceQueryController_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "cloud.planton.apis.v1.code2cloud.deploy.microservice.MicroserviceInstanceQueryController",
	HandlerType: (*MicroserviceInstanceQueryControllerServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "list",
			Handler:    _MicroserviceInstanceQueryController_List_Handler,
		},
		{
			MethodName: "getById",
			Handler:    _MicroserviceInstanceQueryController_GetById_Handler,
		},
		{
			MethodName: "findByProductId",
			Handler:    _MicroserviceInstanceQueryController_FindByProductId_Handler,
		},
		{
			MethodName: "findByEnvironmentId",
			Handler:    _MicroserviceInstanceQueryController_FindByEnvironmentId_Handler,
		},
		{
			MethodName: "findByKubeClusterId",
			Handler:    _MicroserviceInstanceQueryController_FindByKubeClusterId_Handler,
		},
		{
			MethodName: "findByEnvironmentIdByCodeProjectId",
			Handler:    _MicroserviceInstanceQueryController_FindByEnvironmentIdByCodeProjectId_Handler,
		},
		{
			MethodName: "findPods",
			Handler:    _MicroserviceInstanceQueryController_FindPods_Handler,
		},
		{
			MethodName: "getByCodeProjectId",
			Handler:    _MicroserviceInstanceQueryController_GetByCodeProjectId_Handler,
		},
		{
			MethodName: "findByCodeProjectUrl",
			Handler:    _MicroserviceInstanceQueryController_FindByCodeProjectUrl_Handler,
		},
		{
			MethodName: "getEnvVarMap",
			Handler:    _MicroserviceInstanceQueryController_GetEnvVarMap_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "getLogStream",
			Handler:       _MicroserviceInstanceQueryController_GetLogStream_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "cloud/planton/apis/v1/code2cloud/deploy/microservice/service.proto",
}

const (
	MicroserviceInstanceStackController_Preview_FullMethodName = "/cloud.planton.apis.v1.code2cloud.deploy.microservice.MicroserviceInstanceStackController/preview"
	MicroserviceInstanceStackController_Apply_FullMethodName   = "/cloud.planton.apis.v1.code2cloud.deploy.microservice.MicroserviceInstanceStackController/apply"
)

// MicroserviceInstanceStackControllerClient is the client API for MicroserviceInstanceStackController service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type MicroserviceInstanceStackControllerClient interface {
	// preview microservice-instance stack
	Preview(ctx context.Context, in *MicroserviceInstance, opts ...grpc.CallOption) (*MicroserviceInstance, error)
	// apply microservice-instance stack
	Apply(ctx context.Context, in *MicroserviceInstanceId, opts ...grpc.CallOption) (*MicroserviceInstance, error)
}

type microserviceInstanceStackControllerClient struct {
	cc grpc.ClientConnInterface
}

func NewMicroserviceInstanceStackControllerClient(cc grpc.ClientConnInterface) MicroserviceInstanceStackControllerClient {
	return &microserviceInstanceStackControllerClient{cc}
}

func (c *microserviceInstanceStackControllerClient) Preview(ctx context.Context, in *MicroserviceInstance, opts ...grpc.CallOption) (*MicroserviceInstance, error) {
	out := new(MicroserviceInstance)
	err := c.cc.Invoke(ctx, MicroserviceInstanceStackController_Preview_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *microserviceInstanceStackControllerClient) Apply(ctx context.Context, in *MicroserviceInstanceId, opts ...grpc.CallOption) (*MicroserviceInstance, error) {
	out := new(MicroserviceInstance)
	err := c.cc.Invoke(ctx, MicroserviceInstanceStackController_Apply_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// MicroserviceInstanceStackControllerServer is the server API for MicroserviceInstanceStackController service.
// All implementations should embed UnimplementedMicroserviceInstanceStackControllerServer
// for forward compatibility
type MicroserviceInstanceStackControllerServer interface {
	// preview microservice-instance stack
	Preview(context.Context, *MicroserviceInstance) (*MicroserviceInstance, error)
	// apply microservice-instance stack
	Apply(context.Context, *MicroserviceInstanceId) (*MicroserviceInstance, error)
}

// UnimplementedMicroserviceInstanceStackControllerServer should be embedded to have forward compatible implementations.
type UnimplementedMicroserviceInstanceStackControllerServer struct {
}

func (UnimplementedMicroserviceInstanceStackControllerServer) Preview(context.Context, *MicroserviceInstance) (*MicroserviceInstance, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Preview not implemented")
}
func (UnimplementedMicroserviceInstanceStackControllerServer) Apply(context.Context, *MicroserviceInstanceId) (*MicroserviceInstance, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Apply not implemented")
}

// UnsafeMicroserviceInstanceStackControllerServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to MicroserviceInstanceStackControllerServer will
// result in compilation errors.
type UnsafeMicroserviceInstanceStackControllerServer interface {
	mustEmbedUnimplementedMicroserviceInstanceStackControllerServer()
}

func RegisterMicroserviceInstanceStackControllerServer(s grpc.ServiceRegistrar, srv MicroserviceInstanceStackControllerServer) {
	s.RegisterService(&MicroserviceInstanceStackController_ServiceDesc, srv)
}

func _MicroserviceInstanceStackController_Preview_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MicroserviceInstance)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MicroserviceInstanceStackControllerServer).Preview(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MicroserviceInstanceStackController_Preview_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MicroserviceInstanceStackControllerServer).Preview(ctx, req.(*MicroserviceInstance))
	}
	return interceptor(ctx, in, info, handler)
}

func _MicroserviceInstanceStackController_Apply_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MicroserviceInstanceId)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MicroserviceInstanceStackControllerServer).Apply(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MicroserviceInstanceStackController_Apply_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MicroserviceInstanceStackControllerServer).Apply(ctx, req.(*MicroserviceInstanceId))
	}
	return interceptor(ctx, in, info, handler)
}

// MicroserviceInstanceStackController_ServiceDesc is the grpc.ServiceDesc for MicroserviceInstanceStackController service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var MicroserviceInstanceStackController_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "cloud.planton.apis.v1.code2cloud.deploy.microservice.MicroserviceInstanceStackController",
	HandlerType: (*MicroserviceInstanceStackControllerServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "preview",
			Handler:    _MicroserviceInstanceStackController_Preview_Handler,
		},
		{
			MethodName: "apply",
			Handler:    _MicroserviceInstanceStackController_Apply_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "cloud/planton/apis/v1/code2cloud/deploy/microservice/service.proto",
}
