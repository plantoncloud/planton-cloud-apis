// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.3.0
// - protoc             (unknown)
// source: cloud/planton/apis/v1/code2cloud/deploy/kubecluster/rpc/service.proto

package rpc

import (
	context "context"
	rpc1 "github.com/plantoncloud/planton-cloud-apis/zzgo/cloud/planton/apis/v1/code2cloud/cloudaccount/rpc"
	stream "github.com/plantoncloud/planton-cloud-apis/zzgo/cloud/planton/apis/v1/commons/grpc/stream"
	custom "github.com/plantoncloud/planton-cloud-apis/zzgo/cloud/planton/apis/v1/commons/protobuf/custom"
	pagination "github.com/plantoncloud/planton-cloud-apis/zzgo/cloud/planton/apis/v1/commons/rpc/pagination"
	resource "github.com/plantoncloud/planton-cloud-apis/zzgo/cloud/planton/apis/v1/integration/kubernetes/resource"
	rpc "github.com/plantoncloud/planton-cloud-apis/zzgo/cloud/planton/apis/v1/resourcemanager/company/rpc"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

const (
	KubeClusterCommandController_Create_FullMethodName          = "/cloud.planton.apis.v1.code2cloud.deploy.kubecluster.rpc.KubeClusterCommandController/create"
	KubeClusterCommandController_Update_FullMethodName          = "/cloud.planton.apis.v1.code2cloud.deploy.kubecluster.rpc.KubeClusterCommandController/update"
	KubeClusterCommandController_Delete_FullMethodName          = "/cloud.planton.apis.v1.code2cloud.deploy.kubecluster.rpc.KubeClusterCommandController/delete"
	KubeClusterCommandController_Restore_FullMethodName         = "/cloud.planton.apis.v1.code2cloud.deploy.kubecluster.rpc.KubeClusterCommandController/restore"
	KubeClusterCommandController_Pause_FullMethodName           = "/cloud.planton.apis.v1.code2cloud.deploy.kubecluster.rpc.KubeClusterCommandController/pause"
	KubeClusterCommandController_Unpause_FullMethodName         = "/cloud.planton.apis.v1.code2cloud.deploy.kubecluster.rpc.KubeClusterCommandController/unpause"
	KubeClusterCommandController_DeleteNamespace_FullMethodName = "/cloud.planton.apis.v1.code2cloud.deploy.kubecluster.rpc.KubeClusterCommandController/deleteNamespace"
	KubeClusterCommandController_DeletePod_FullMethodName       = "/cloud.planton.apis.v1.code2cloud.deploy.kubecluster.rpc.KubeClusterCommandController/deletePod"
)

// KubeClusterCommandControllerClient is the client API for KubeClusterCommandController service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type KubeClusterCommandControllerClient interface {
	// create a new kube-cluster.
	Create(ctx context.Context, in *KubeCluster, opts ...grpc.CallOption) (*KubeCluster, error)
	// update an existing kube-cluster.
	Update(ctx context.Context, in *KubeCluster, opts ...grpc.CallOption) (*KubeCluster, error)
	// delete a kube-cluster.
	Delete(ctx context.Context, in *KubeClusterId, opts ...grpc.CallOption) (*KubeCluster, error)
	// restore a deleted kube-cluster.
	Restore(ctx context.Context, in *KubeCluster, opts ...grpc.CallOption) (*KubeCluster, error)
	// pause a kube-cluster.
	// a kube-cluster is paused by setting the number of nodes in each node pool of the kube-cluster to zero.
	// microservice, database and kafka cluster workload pods will be deleted as there wont be any nodes to run on.
	// when the kube-cluster is resumed, the pods come back up online automatically when nodes become available.
	// when a kube-cluster is paused, cloud provider will not charge for the compute resources(cpu & memory) but
	// may continue to charge a modest operational fee for the cluster.
	Pause(ctx context.Context, in *KubeClusterId, opts ...grpc.CallOption) (*KubeCluster, error)
	// unpause a kube-cluster.
	// a kube-cluster is resumed by setting the number of nodes in each node pool of the kube-cluster to the
	// values configured for the kube-cluster.
	// when the kube-cluster is resumed, the pods come back up online automatically when nodes become available.
	Unpause(ctx context.Context, in *KubeClusterId, opts ...grpc.CallOption) (*KubeCluster, error)
	// delete a namespace in kube-cluster kube-cluster
	DeleteNamespace(ctx context.Context, in *ByKubeClusterByNamespaceInput, opts ...grpc.CallOption) (*resource.WorkloadNamespace, error)
	// delete a pod in kube-cluster kube-cluster
	DeletePod(ctx context.Context, in *ByKubeClusterByNamespaceByPodInput, opts ...grpc.CallOption) (*resource.Pod, error)
}

type kubeClusterCommandControllerClient struct {
	cc grpc.ClientConnInterface
}

func NewKubeClusterCommandControllerClient(cc grpc.ClientConnInterface) KubeClusterCommandControllerClient {
	return &kubeClusterCommandControllerClient{cc}
}

func (c *kubeClusterCommandControllerClient) Create(ctx context.Context, in *KubeCluster, opts ...grpc.CallOption) (*KubeCluster, error) {
	out := new(KubeCluster)
	err := c.cc.Invoke(ctx, KubeClusterCommandController_Create_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *kubeClusterCommandControllerClient) Update(ctx context.Context, in *KubeCluster, opts ...grpc.CallOption) (*KubeCluster, error) {
	out := new(KubeCluster)
	err := c.cc.Invoke(ctx, KubeClusterCommandController_Update_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *kubeClusterCommandControllerClient) Delete(ctx context.Context, in *KubeClusterId, opts ...grpc.CallOption) (*KubeCluster, error) {
	out := new(KubeCluster)
	err := c.cc.Invoke(ctx, KubeClusterCommandController_Delete_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *kubeClusterCommandControllerClient) Restore(ctx context.Context, in *KubeCluster, opts ...grpc.CallOption) (*KubeCluster, error) {
	out := new(KubeCluster)
	err := c.cc.Invoke(ctx, KubeClusterCommandController_Restore_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *kubeClusterCommandControllerClient) Pause(ctx context.Context, in *KubeClusterId, opts ...grpc.CallOption) (*KubeCluster, error) {
	out := new(KubeCluster)
	err := c.cc.Invoke(ctx, KubeClusterCommandController_Pause_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *kubeClusterCommandControllerClient) Unpause(ctx context.Context, in *KubeClusterId, opts ...grpc.CallOption) (*KubeCluster, error) {
	out := new(KubeCluster)
	err := c.cc.Invoke(ctx, KubeClusterCommandController_Unpause_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *kubeClusterCommandControllerClient) DeleteNamespace(ctx context.Context, in *ByKubeClusterByNamespaceInput, opts ...grpc.CallOption) (*resource.WorkloadNamespace, error) {
	out := new(resource.WorkloadNamespace)
	err := c.cc.Invoke(ctx, KubeClusterCommandController_DeleteNamespace_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *kubeClusterCommandControllerClient) DeletePod(ctx context.Context, in *ByKubeClusterByNamespaceByPodInput, opts ...grpc.CallOption) (*resource.Pod, error) {
	out := new(resource.Pod)
	err := c.cc.Invoke(ctx, KubeClusterCommandController_DeletePod_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// KubeClusterCommandControllerServer is the server API for KubeClusterCommandController service.
// All implementations should embed UnimplementedKubeClusterCommandControllerServer
// for forward compatibility
type KubeClusterCommandControllerServer interface {
	// create a new kube-cluster.
	Create(context.Context, *KubeCluster) (*KubeCluster, error)
	// update an existing kube-cluster.
	Update(context.Context, *KubeCluster) (*KubeCluster, error)
	// delete a kube-cluster.
	Delete(context.Context, *KubeClusterId) (*KubeCluster, error)
	// restore a deleted kube-cluster.
	Restore(context.Context, *KubeCluster) (*KubeCluster, error)
	// pause a kube-cluster.
	// a kube-cluster is paused by setting the number of nodes in each node pool of the kube-cluster to zero.
	// microservice, database and kafka cluster workload pods will be deleted as there wont be any nodes to run on.
	// when the kube-cluster is resumed, the pods come back up online automatically when nodes become available.
	// when a kube-cluster is paused, cloud provider will not charge for the compute resources(cpu & memory) but
	// may continue to charge a modest operational fee for the cluster.
	Pause(context.Context, *KubeClusterId) (*KubeCluster, error)
	// unpause a kube-cluster.
	// a kube-cluster is resumed by setting the number of nodes in each node pool of the kube-cluster to the
	// values configured for the kube-cluster.
	// when the kube-cluster is resumed, the pods come back up online automatically when nodes become available.
	Unpause(context.Context, *KubeClusterId) (*KubeCluster, error)
	// delete a namespace in kube-cluster kube-cluster
	DeleteNamespace(context.Context, *ByKubeClusterByNamespaceInput) (*resource.WorkloadNamespace, error)
	// delete a pod in kube-cluster kube-cluster
	DeletePod(context.Context, *ByKubeClusterByNamespaceByPodInput) (*resource.Pod, error)
}

// UnimplementedKubeClusterCommandControllerServer should be embedded to have forward compatible implementations.
type UnimplementedKubeClusterCommandControllerServer struct {
}

func (UnimplementedKubeClusterCommandControllerServer) Create(context.Context, *KubeCluster) (*KubeCluster, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Create not implemented")
}
func (UnimplementedKubeClusterCommandControllerServer) Update(context.Context, *KubeCluster) (*KubeCluster, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Update not implemented")
}
func (UnimplementedKubeClusterCommandControllerServer) Delete(context.Context, *KubeClusterId) (*KubeCluster, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Delete not implemented")
}
func (UnimplementedKubeClusterCommandControllerServer) Restore(context.Context, *KubeCluster) (*KubeCluster, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Restore not implemented")
}
func (UnimplementedKubeClusterCommandControllerServer) Pause(context.Context, *KubeClusterId) (*KubeCluster, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Pause not implemented")
}
func (UnimplementedKubeClusterCommandControllerServer) Unpause(context.Context, *KubeClusterId) (*KubeCluster, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Unpause not implemented")
}
func (UnimplementedKubeClusterCommandControllerServer) DeleteNamespace(context.Context, *ByKubeClusterByNamespaceInput) (*resource.WorkloadNamespace, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteNamespace not implemented")
}
func (UnimplementedKubeClusterCommandControllerServer) DeletePod(context.Context, *ByKubeClusterByNamespaceByPodInput) (*resource.Pod, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeletePod not implemented")
}

// UnsafeKubeClusterCommandControllerServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to KubeClusterCommandControllerServer will
// result in compilation errors.
type UnsafeKubeClusterCommandControllerServer interface {
	mustEmbedUnimplementedKubeClusterCommandControllerServer()
}

func RegisterKubeClusterCommandControllerServer(s grpc.ServiceRegistrar, srv KubeClusterCommandControllerServer) {
	s.RegisterService(&KubeClusterCommandController_ServiceDesc, srv)
}

func _KubeClusterCommandController_Create_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(KubeCluster)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KubeClusterCommandControllerServer).Create(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: KubeClusterCommandController_Create_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KubeClusterCommandControllerServer).Create(ctx, req.(*KubeCluster))
	}
	return interceptor(ctx, in, info, handler)
}

func _KubeClusterCommandController_Update_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(KubeCluster)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KubeClusterCommandControllerServer).Update(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: KubeClusterCommandController_Update_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KubeClusterCommandControllerServer).Update(ctx, req.(*KubeCluster))
	}
	return interceptor(ctx, in, info, handler)
}

func _KubeClusterCommandController_Delete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(KubeClusterId)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KubeClusterCommandControllerServer).Delete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: KubeClusterCommandController_Delete_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KubeClusterCommandControllerServer).Delete(ctx, req.(*KubeClusterId))
	}
	return interceptor(ctx, in, info, handler)
}

func _KubeClusterCommandController_Restore_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(KubeCluster)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KubeClusterCommandControllerServer).Restore(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: KubeClusterCommandController_Restore_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KubeClusterCommandControllerServer).Restore(ctx, req.(*KubeCluster))
	}
	return interceptor(ctx, in, info, handler)
}

func _KubeClusterCommandController_Pause_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(KubeClusterId)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KubeClusterCommandControllerServer).Pause(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: KubeClusterCommandController_Pause_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KubeClusterCommandControllerServer).Pause(ctx, req.(*KubeClusterId))
	}
	return interceptor(ctx, in, info, handler)
}

func _KubeClusterCommandController_Unpause_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(KubeClusterId)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KubeClusterCommandControllerServer).Unpause(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: KubeClusterCommandController_Unpause_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KubeClusterCommandControllerServer).Unpause(ctx, req.(*KubeClusterId))
	}
	return interceptor(ctx, in, info, handler)
}

func _KubeClusterCommandController_DeleteNamespace_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ByKubeClusterByNamespaceInput)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KubeClusterCommandControllerServer).DeleteNamespace(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: KubeClusterCommandController_DeleteNamespace_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KubeClusterCommandControllerServer).DeleteNamespace(ctx, req.(*ByKubeClusterByNamespaceInput))
	}
	return interceptor(ctx, in, info, handler)
}

func _KubeClusterCommandController_DeletePod_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ByKubeClusterByNamespaceByPodInput)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KubeClusterCommandControllerServer).DeletePod(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: KubeClusterCommandController_DeletePod_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KubeClusterCommandControllerServer).DeletePod(ctx, req.(*ByKubeClusterByNamespaceByPodInput))
	}
	return interceptor(ctx, in, info, handler)
}

// KubeClusterCommandController_ServiceDesc is the grpc.ServiceDesc for KubeClusterCommandController service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var KubeClusterCommandController_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "cloud.planton.apis.v1.code2cloud.deploy.kubecluster.rpc.KubeClusterCommandController",
	HandlerType: (*KubeClusterCommandControllerServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "create",
			Handler:    _KubeClusterCommandController_Create_Handler,
		},
		{
			MethodName: "update",
			Handler:    _KubeClusterCommandController_Update_Handler,
		},
		{
			MethodName: "delete",
			Handler:    _KubeClusterCommandController_Delete_Handler,
		},
		{
			MethodName: "restore",
			Handler:    _KubeClusterCommandController_Restore_Handler,
		},
		{
			MethodName: "pause",
			Handler:    _KubeClusterCommandController_Pause_Handler,
		},
		{
			MethodName: "unpause",
			Handler:    _KubeClusterCommandController_Unpause_Handler,
		},
		{
			MethodName: "deleteNamespace",
			Handler:    _KubeClusterCommandController_DeleteNamespace_Handler,
		},
		{
			MethodName: "deletePod",
			Handler:    _KubeClusterCommandController_DeletePod_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "cloud/planton/apis/v1/code2cloud/deploy/kubecluster/rpc/service.proto",
}

const (
	KubeClusterQueryController_List_FullMethodName                                    = "/cloud.planton.apis.v1.code2cloud.deploy.kubecluster.rpc.KubeClusterQueryController/list"
	KubeClusterQueryController_GetById_FullMethodName                                 = "/cloud.planton.apis.v1.code2cloud.deploy.kubecluster.rpc.KubeClusterQueryController/getById"
	KubeClusterQueryController_FindByCompanyId_FullMethodName                         = "/cloud.planton.apis.v1.code2cloud.deploy.kubecluster.rpc.KubeClusterQueryController/findByCompanyId"
	KubeClusterQueryController_FindByCloudAccountId_FullMethodName                    = "/cloud.planton.apis.v1.code2cloud.deploy.kubecluster.rpc.KubeClusterQueryController/findByCloudAccountId"
	KubeClusterQueryController_FindEnvironmentCreateKubeClusters_FullMethodName       = "/cloud.planton.apis.v1.code2cloud.deploy.kubecluster.rpc.KubeClusterQueryController/findEnvironmentCreateKubeClusters"
	KubeClusterQueryController_GetKubeClusterComponentsByKubeClusterId_FullMethodName = "/cloud.planton.apis.v1.code2cloud.deploy.kubecluster.rpc.KubeClusterQueryController/getKubeClusterComponentsByKubeClusterId"
	KubeClusterQueryController_FindWorkloadNamespacesByKubeClusterId_FullMethodName   = "/cloud.planton.apis.v1.code2cloud.deploy.kubecluster.rpc.KubeClusterQueryController/findWorkloadNamespacesByKubeClusterId"
	KubeClusterQueryController_FindWorkloadPodsByKubeClusterId_FullMethodName         = "/cloud.planton.apis.v1.code2cloud.deploy.kubecluster.rpc.KubeClusterQueryController/findWorkloadPodsByKubeClusterId"
	KubeClusterQueryController_FindSslCertificatesByKubeClusterId_FullMethodName      = "/cloud.planton.apis.v1.code2cloud.deploy.kubecluster.rpc.KubeClusterQueryController/findSslCertificatesByKubeClusterId"
	KubeClusterQueryController_GetPod_FullMethodName                                  = "/cloud.planton.apis.v1.code2cloud.deploy.kubecluster.rpc.KubeClusterQueryController/getPod"
	KubeClusterQueryController_GetPodLogStream_FullMethodName                         = "/cloud.planton.apis.v1.code2cloud.deploy.kubecluster.rpc.KubeClusterQueryController/getPodLogStream"
)

// KubeClusterQueryControllerClient is the client API for KubeClusterQueryController service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type KubeClusterQueryControllerClient interface {
	// list all kube-clusters on planton cloud for the requested page. This is intended for use on portal.
	List(ctx context.Context, in *pagination.PageInfo, opts ...grpc.CallOption) (*KubeClusterList, error)
	// lookup kube-cluster using kube-cluster id
	GetById(ctx context.Context, in *KubeClusterId, opts ...grpc.CallOption) (*KubeCluster, error)
	// find kube-clusters by company id
	FindByCompanyId(ctx context.Context, in *rpc.CompanyId, opts ...grpc.CallOption) (*KubeClusters, error)
	// find kube-clusters in a cloud account.
	FindByCloudAccountId(ctx context.Context, in *rpc1.CloudAccountId, opts ...grpc.CallOption) (*KubeClusters, error)
	// find kube-clusters by company id to create environment.
	// this will be used to populate drop down of kube-clusters in create environment form.
	// the response should only include kube-clusters that a company is authorised to create environment.
	// the authorization is verified by looking up kube-clusters with `company-environment-creator` relation with the company id provided in input.
	FindEnvironmentCreateKubeClusters(ctx context.Context, in *rpc.CompanyId, opts ...grpc.CallOption) (*KubeClusters, error)
	// lookup components in a kube-cluster of a kube-cluster
	GetKubeClusterComponentsByKubeClusterId(ctx context.Context, in *KubeClusterId, opts ...grpc.CallOption) (*KubeClusterComponents, error)
	// find workload namespaces in a kube-cluster.
	FindWorkloadNamespacesByKubeClusterId(ctx context.Context, in *KubeClusterId, opts ...grpc.CallOption) (*resource.WorkloadNamespaces, error)
	// find workload pods part of all environments hosted in a kube-cluster.
	FindWorkloadPodsByKubeClusterId(ctx context.Context, in *KubeClusterId, opts ...grpc.CallOption) (*resource.WorkloadPods, error)
	// find workload pods part of all environments hosted in a kube-cluster.
	FindSslCertificatesByKubeClusterId(ctx context.Context, in *KubeClusterId, opts ...grpc.CallOption) (*resource.Certificates, error)
	// get a pod details
	GetPod(ctx context.Context, in *ByKubeClusterByNamespaceByPodInput, opts ...grpc.CallOption) (*resource.Pod, error)
	// get a log stream for a pod running in a kube-cluster kube-cluster
	GetPodLogStream(ctx context.Context, in *ByKubeClusterByNamespaceByPodInput, opts ...grpc.CallOption) (KubeClusterQueryController_GetPodLogStreamClient, error)
}

type kubeClusterQueryControllerClient struct {
	cc grpc.ClientConnInterface
}

func NewKubeClusterQueryControllerClient(cc grpc.ClientConnInterface) KubeClusterQueryControllerClient {
	return &kubeClusterQueryControllerClient{cc}
}

func (c *kubeClusterQueryControllerClient) List(ctx context.Context, in *pagination.PageInfo, opts ...grpc.CallOption) (*KubeClusterList, error) {
	out := new(KubeClusterList)
	err := c.cc.Invoke(ctx, KubeClusterQueryController_List_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *kubeClusterQueryControllerClient) GetById(ctx context.Context, in *KubeClusterId, opts ...grpc.CallOption) (*KubeCluster, error) {
	out := new(KubeCluster)
	err := c.cc.Invoke(ctx, KubeClusterQueryController_GetById_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *kubeClusterQueryControllerClient) FindByCompanyId(ctx context.Context, in *rpc.CompanyId, opts ...grpc.CallOption) (*KubeClusters, error) {
	out := new(KubeClusters)
	err := c.cc.Invoke(ctx, KubeClusterQueryController_FindByCompanyId_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *kubeClusterQueryControllerClient) FindByCloudAccountId(ctx context.Context, in *rpc1.CloudAccountId, opts ...grpc.CallOption) (*KubeClusters, error) {
	out := new(KubeClusters)
	err := c.cc.Invoke(ctx, KubeClusterQueryController_FindByCloudAccountId_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *kubeClusterQueryControllerClient) FindEnvironmentCreateKubeClusters(ctx context.Context, in *rpc.CompanyId, opts ...grpc.CallOption) (*KubeClusters, error) {
	out := new(KubeClusters)
	err := c.cc.Invoke(ctx, KubeClusterQueryController_FindEnvironmentCreateKubeClusters_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *kubeClusterQueryControllerClient) GetKubeClusterComponentsByKubeClusterId(ctx context.Context, in *KubeClusterId, opts ...grpc.CallOption) (*KubeClusterComponents, error) {
	out := new(KubeClusterComponents)
	err := c.cc.Invoke(ctx, KubeClusterQueryController_GetKubeClusterComponentsByKubeClusterId_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *kubeClusterQueryControllerClient) FindWorkloadNamespacesByKubeClusterId(ctx context.Context, in *KubeClusterId, opts ...grpc.CallOption) (*resource.WorkloadNamespaces, error) {
	out := new(resource.WorkloadNamespaces)
	err := c.cc.Invoke(ctx, KubeClusterQueryController_FindWorkloadNamespacesByKubeClusterId_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *kubeClusterQueryControllerClient) FindWorkloadPodsByKubeClusterId(ctx context.Context, in *KubeClusterId, opts ...grpc.CallOption) (*resource.WorkloadPods, error) {
	out := new(resource.WorkloadPods)
	err := c.cc.Invoke(ctx, KubeClusterQueryController_FindWorkloadPodsByKubeClusterId_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *kubeClusterQueryControllerClient) FindSslCertificatesByKubeClusterId(ctx context.Context, in *KubeClusterId, opts ...grpc.CallOption) (*resource.Certificates, error) {
	out := new(resource.Certificates)
	err := c.cc.Invoke(ctx, KubeClusterQueryController_FindSslCertificatesByKubeClusterId_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *kubeClusterQueryControllerClient) GetPod(ctx context.Context, in *ByKubeClusterByNamespaceByPodInput, opts ...grpc.CallOption) (*resource.Pod, error) {
	out := new(resource.Pod)
	err := c.cc.Invoke(ctx, KubeClusterQueryController_GetPod_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *kubeClusterQueryControllerClient) GetPodLogStream(ctx context.Context, in *ByKubeClusterByNamespaceByPodInput, opts ...grpc.CallOption) (KubeClusterQueryController_GetPodLogStreamClient, error) {
	stream, err := c.cc.NewStream(ctx, &KubeClusterQueryController_ServiceDesc.Streams[0], KubeClusterQueryController_GetPodLogStream_FullMethodName, opts...)
	if err != nil {
		return nil, err
	}
	x := &kubeClusterQueryControllerGetPodLogStreamClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type KubeClusterQueryController_GetPodLogStreamClient interface {
	Recv() (*stream.OutputLine, error)
	grpc.ClientStream
}

type kubeClusterQueryControllerGetPodLogStreamClient struct {
	grpc.ClientStream
}

func (x *kubeClusterQueryControllerGetPodLogStreamClient) Recv() (*stream.OutputLine, error) {
	m := new(stream.OutputLine)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// KubeClusterQueryControllerServer is the server API for KubeClusterQueryController service.
// All implementations should embed UnimplementedKubeClusterQueryControllerServer
// for forward compatibility
type KubeClusterQueryControllerServer interface {
	// list all kube-clusters on planton cloud for the requested page. This is intended for use on portal.
	List(context.Context, *pagination.PageInfo) (*KubeClusterList, error)
	// lookup kube-cluster using kube-cluster id
	GetById(context.Context, *KubeClusterId) (*KubeCluster, error)
	// find kube-clusters by company id
	FindByCompanyId(context.Context, *rpc.CompanyId) (*KubeClusters, error)
	// find kube-clusters in a cloud account.
	FindByCloudAccountId(context.Context, *rpc1.CloudAccountId) (*KubeClusters, error)
	// find kube-clusters by company id to create environment.
	// this will be used to populate drop down of kube-clusters in create environment form.
	// the response should only include kube-clusters that a company is authorised to create environment.
	// the authorization is verified by looking up kube-clusters with `company-environment-creator` relation with the company id provided in input.
	FindEnvironmentCreateKubeClusters(context.Context, *rpc.CompanyId) (*KubeClusters, error)
	// lookup components in a kube-cluster of a kube-cluster
	GetKubeClusterComponentsByKubeClusterId(context.Context, *KubeClusterId) (*KubeClusterComponents, error)
	// find workload namespaces in a kube-cluster.
	FindWorkloadNamespacesByKubeClusterId(context.Context, *KubeClusterId) (*resource.WorkloadNamespaces, error)
	// find workload pods part of all environments hosted in a kube-cluster.
	FindWorkloadPodsByKubeClusterId(context.Context, *KubeClusterId) (*resource.WorkloadPods, error)
	// find workload pods part of all environments hosted in a kube-cluster.
	FindSslCertificatesByKubeClusterId(context.Context, *KubeClusterId) (*resource.Certificates, error)
	// get a pod details
	GetPod(context.Context, *ByKubeClusterByNamespaceByPodInput) (*resource.Pod, error)
	// get a log stream for a pod running in a kube-cluster kube-cluster
	GetPodLogStream(*ByKubeClusterByNamespaceByPodInput, KubeClusterQueryController_GetPodLogStreamServer) error
}

// UnimplementedKubeClusterQueryControllerServer should be embedded to have forward compatible implementations.
type UnimplementedKubeClusterQueryControllerServer struct {
}

func (UnimplementedKubeClusterQueryControllerServer) List(context.Context, *pagination.PageInfo) (*KubeClusterList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method List not implemented")
}
func (UnimplementedKubeClusterQueryControllerServer) GetById(context.Context, *KubeClusterId) (*KubeCluster, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetById not implemented")
}
func (UnimplementedKubeClusterQueryControllerServer) FindByCompanyId(context.Context, *rpc.CompanyId) (*KubeClusters, error) {
	return nil, status.Errorf(codes.Unimplemented, "method FindByCompanyId not implemented")
}
func (UnimplementedKubeClusterQueryControllerServer) FindByCloudAccountId(context.Context, *rpc1.CloudAccountId) (*KubeClusters, error) {
	return nil, status.Errorf(codes.Unimplemented, "method FindByCloudAccountId not implemented")
}
func (UnimplementedKubeClusterQueryControllerServer) FindEnvironmentCreateKubeClusters(context.Context, *rpc.CompanyId) (*KubeClusters, error) {
	return nil, status.Errorf(codes.Unimplemented, "method FindEnvironmentCreateKubeClusters not implemented")
}
func (UnimplementedKubeClusterQueryControllerServer) GetKubeClusterComponentsByKubeClusterId(context.Context, *KubeClusterId) (*KubeClusterComponents, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetKubeClusterComponentsByKubeClusterId not implemented")
}
func (UnimplementedKubeClusterQueryControllerServer) FindWorkloadNamespacesByKubeClusterId(context.Context, *KubeClusterId) (*resource.WorkloadNamespaces, error) {
	return nil, status.Errorf(codes.Unimplemented, "method FindWorkloadNamespacesByKubeClusterId not implemented")
}
func (UnimplementedKubeClusterQueryControllerServer) FindWorkloadPodsByKubeClusterId(context.Context, *KubeClusterId) (*resource.WorkloadPods, error) {
	return nil, status.Errorf(codes.Unimplemented, "method FindWorkloadPodsByKubeClusterId not implemented")
}
func (UnimplementedKubeClusterQueryControllerServer) FindSslCertificatesByKubeClusterId(context.Context, *KubeClusterId) (*resource.Certificates, error) {
	return nil, status.Errorf(codes.Unimplemented, "method FindSslCertificatesByKubeClusterId not implemented")
}
func (UnimplementedKubeClusterQueryControllerServer) GetPod(context.Context, *ByKubeClusterByNamespaceByPodInput) (*resource.Pod, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetPod not implemented")
}
func (UnimplementedKubeClusterQueryControllerServer) GetPodLogStream(*ByKubeClusterByNamespaceByPodInput, KubeClusterQueryController_GetPodLogStreamServer) error {
	return status.Errorf(codes.Unimplemented, "method GetPodLogStream not implemented")
}

// UnsafeKubeClusterQueryControllerServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to KubeClusterQueryControllerServer will
// result in compilation errors.
type UnsafeKubeClusterQueryControllerServer interface {
	mustEmbedUnimplementedKubeClusterQueryControllerServer()
}

func RegisterKubeClusterQueryControllerServer(s grpc.ServiceRegistrar, srv KubeClusterQueryControllerServer) {
	s.RegisterService(&KubeClusterQueryController_ServiceDesc, srv)
}

func _KubeClusterQueryController_List_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(pagination.PageInfo)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KubeClusterQueryControllerServer).List(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: KubeClusterQueryController_List_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KubeClusterQueryControllerServer).List(ctx, req.(*pagination.PageInfo))
	}
	return interceptor(ctx, in, info, handler)
}

func _KubeClusterQueryController_GetById_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(KubeClusterId)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KubeClusterQueryControllerServer).GetById(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: KubeClusterQueryController_GetById_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KubeClusterQueryControllerServer).GetById(ctx, req.(*KubeClusterId))
	}
	return interceptor(ctx, in, info, handler)
}

func _KubeClusterQueryController_FindByCompanyId_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(rpc.CompanyId)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KubeClusterQueryControllerServer).FindByCompanyId(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: KubeClusterQueryController_FindByCompanyId_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KubeClusterQueryControllerServer).FindByCompanyId(ctx, req.(*rpc.CompanyId))
	}
	return interceptor(ctx, in, info, handler)
}

func _KubeClusterQueryController_FindByCloudAccountId_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(rpc1.CloudAccountId)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KubeClusterQueryControllerServer).FindByCloudAccountId(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: KubeClusterQueryController_FindByCloudAccountId_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KubeClusterQueryControllerServer).FindByCloudAccountId(ctx, req.(*rpc1.CloudAccountId))
	}
	return interceptor(ctx, in, info, handler)
}

func _KubeClusterQueryController_FindEnvironmentCreateKubeClusters_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(rpc.CompanyId)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KubeClusterQueryControllerServer).FindEnvironmentCreateKubeClusters(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: KubeClusterQueryController_FindEnvironmentCreateKubeClusters_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KubeClusterQueryControllerServer).FindEnvironmentCreateKubeClusters(ctx, req.(*rpc.CompanyId))
	}
	return interceptor(ctx, in, info, handler)
}

func _KubeClusterQueryController_GetKubeClusterComponentsByKubeClusterId_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(KubeClusterId)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KubeClusterQueryControllerServer).GetKubeClusterComponentsByKubeClusterId(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: KubeClusterQueryController_GetKubeClusterComponentsByKubeClusterId_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KubeClusterQueryControllerServer).GetKubeClusterComponentsByKubeClusterId(ctx, req.(*KubeClusterId))
	}
	return interceptor(ctx, in, info, handler)
}

func _KubeClusterQueryController_FindWorkloadNamespacesByKubeClusterId_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(KubeClusterId)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KubeClusterQueryControllerServer).FindWorkloadNamespacesByKubeClusterId(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: KubeClusterQueryController_FindWorkloadNamespacesByKubeClusterId_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KubeClusterQueryControllerServer).FindWorkloadNamespacesByKubeClusterId(ctx, req.(*KubeClusterId))
	}
	return interceptor(ctx, in, info, handler)
}

func _KubeClusterQueryController_FindWorkloadPodsByKubeClusterId_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(KubeClusterId)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KubeClusterQueryControllerServer).FindWorkloadPodsByKubeClusterId(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: KubeClusterQueryController_FindWorkloadPodsByKubeClusterId_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KubeClusterQueryControllerServer).FindWorkloadPodsByKubeClusterId(ctx, req.(*KubeClusterId))
	}
	return interceptor(ctx, in, info, handler)
}

func _KubeClusterQueryController_FindSslCertificatesByKubeClusterId_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(KubeClusterId)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KubeClusterQueryControllerServer).FindSslCertificatesByKubeClusterId(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: KubeClusterQueryController_FindSslCertificatesByKubeClusterId_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KubeClusterQueryControllerServer).FindSslCertificatesByKubeClusterId(ctx, req.(*KubeClusterId))
	}
	return interceptor(ctx, in, info, handler)
}

func _KubeClusterQueryController_GetPod_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ByKubeClusterByNamespaceByPodInput)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KubeClusterQueryControllerServer).GetPod(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: KubeClusterQueryController_GetPod_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KubeClusterQueryControllerServer).GetPod(ctx, req.(*ByKubeClusterByNamespaceByPodInput))
	}
	return interceptor(ctx, in, info, handler)
}

func _KubeClusterQueryController_GetPodLogStream_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(ByKubeClusterByNamespaceByPodInput)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(KubeClusterQueryControllerServer).GetPodLogStream(m, &kubeClusterQueryControllerGetPodLogStreamServer{stream})
}

type KubeClusterQueryController_GetPodLogStreamServer interface {
	Send(*stream.OutputLine) error
	grpc.ServerStream
}

type kubeClusterQueryControllerGetPodLogStreamServer struct {
	grpc.ServerStream
}

func (x *kubeClusterQueryControllerGetPodLogStreamServer) Send(m *stream.OutputLine) error {
	return x.ServerStream.SendMsg(m)
}

// KubeClusterQueryController_ServiceDesc is the grpc.ServiceDesc for KubeClusterQueryController service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var KubeClusterQueryController_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "cloud.planton.apis.v1.code2cloud.deploy.kubecluster.rpc.KubeClusterQueryController",
	HandlerType: (*KubeClusterQueryControllerServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "list",
			Handler:    _KubeClusterQueryController_List_Handler,
		},
		{
			MethodName: "getById",
			Handler:    _KubeClusterQueryController_GetById_Handler,
		},
		{
			MethodName: "findByCompanyId",
			Handler:    _KubeClusterQueryController_FindByCompanyId_Handler,
		},
		{
			MethodName: "findByCloudAccountId",
			Handler:    _KubeClusterQueryController_FindByCloudAccountId_Handler,
		},
		{
			MethodName: "findEnvironmentCreateKubeClusters",
			Handler:    _KubeClusterQueryController_FindEnvironmentCreateKubeClusters_Handler,
		},
		{
			MethodName: "getKubeClusterComponentsByKubeClusterId",
			Handler:    _KubeClusterQueryController_GetKubeClusterComponentsByKubeClusterId_Handler,
		},
		{
			MethodName: "findWorkloadNamespacesByKubeClusterId",
			Handler:    _KubeClusterQueryController_FindWorkloadNamespacesByKubeClusterId_Handler,
		},
		{
			MethodName: "findWorkloadPodsByKubeClusterId",
			Handler:    _KubeClusterQueryController_FindWorkloadPodsByKubeClusterId_Handler,
		},
		{
			MethodName: "findSslCertificatesByKubeClusterId",
			Handler:    _KubeClusterQueryController_FindSslCertificatesByKubeClusterId_Handler,
		},
		{
			MethodName: "getPod",
			Handler:    _KubeClusterQueryController_GetPod_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "getPodLogStream",
			Handler:       _KubeClusterQueryController_GetPodLogStream_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "cloud/planton/apis/v1/code2cloud/deploy/kubecluster/rpc/service.proto",
}

const (
	KubeClusterNodePoolGcpCommandController_Add_FullMethodName    = "/cloud.planton.apis.v1.code2cloud.deploy.kubecluster.rpc.KubeClusterNodePoolGcpCommandController/add"
	KubeClusterNodePoolGcpCommandController_Update_FullMethodName = "/cloud.planton.apis.v1.code2cloud.deploy.kubecluster.rpc.KubeClusterNodePoolGcpCommandController/update"
	KubeClusterNodePoolGcpCommandController_Delete_FullMethodName = "/cloud.planton.apis.v1.code2cloud.deploy.kubecluster.rpc.KubeClusterNodePoolGcpCommandController/delete"
)

// KubeClusterNodePoolGcpCommandControllerClient is the client API for KubeClusterNodePoolGcpCommandController service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type KubeClusterNodePoolGcpCommandControllerClient interface {
	// add a node pool to a kube-cluster in a kube-cluster
	Add(ctx context.Context, in *AddOrUpdateKubeClusterNodePoolGcpCommandInput, opts ...grpc.CallOption) (*KubeCluster, error)
	// update a node pool of a kube-cluster in a kube-cluster
	Update(ctx context.Context, in *AddOrUpdateKubeClusterNodePoolGcpCommandInput, opts ...grpc.CallOption) (*KubeCluster, error)
	// delete a node pool from a kube-cluster in a kube-cluster
	Delete(ctx context.Context, in *DeleteKubeClusterNodePoolGcpCommandInput, opts ...grpc.CallOption) (*KubeCluster, error)
}

type kubeClusterNodePoolGcpCommandControllerClient struct {
	cc grpc.ClientConnInterface
}

func NewKubeClusterNodePoolGcpCommandControllerClient(cc grpc.ClientConnInterface) KubeClusterNodePoolGcpCommandControllerClient {
	return &kubeClusterNodePoolGcpCommandControllerClient{cc}
}

func (c *kubeClusterNodePoolGcpCommandControllerClient) Add(ctx context.Context, in *AddOrUpdateKubeClusterNodePoolGcpCommandInput, opts ...grpc.CallOption) (*KubeCluster, error) {
	out := new(KubeCluster)
	err := c.cc.Invoke(ctx, KubeClusterNodePoolGcpCommandController_Add_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *kubeClusterNodePoolGcpCommandControllerClient) Update(ctx context.Context, in *AddOrUpdateKubeClusterNodePoolGcpCommandInput, opts ...grpc.CallOption) (*KubeCluster, error) {
	out := new(KubeCluster)
	err := c.cc.Invoke(ctx, KubeClusterNodePoolGcpCommandController_Update_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *kubeClusterNodePoolGcpCommandControllerClient) Delete(ctx context.Context, in *DeleteKubeClusterNodePoolGcpCommandInput, opts ...grpc.CallOption) (*KubeCluster, error) {
	out := new(KubeCluster)
	err := c.cc.Invoke(ctx, KubeClusterNodePoolGcpCommandController_Delete_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// KubeClusterNodePoolGcpCommandControllerServer is the server API for KubeClusterNodePoolGcpCommandController service.
// All implementations should embed UnimplementedKubeClusterNodePoolGcpCommandControllerServer
// for forward compatibility
type KubeClusterNodePoolGcpCommandControllerServer interface {
	// add a node pool to a kube-cluster in a kube-cluster
	Add(context.Context, *AddOrUpdateKubeClusterNodePoolGcpCommandInput) (*KubeCluster, error)
	// update a node pool of a kube-cluster in a kube-cluster
	Update(context.Context, *AddOrUpdateKubeClusterNodePoolGcpCommandInput) (*KubeCluster, error)
	// delete a node pool from a kube-cluster in a kube-cluster
	Delete(context.Context, *DeleteKubeClusterNodePoolGcpCommandInput) (*KubeCluster, error)
}

// UnimplementedKubeClusterNodePoolGcpCommandControllerServer should be embedded to have forward compatible implementations.
type UnimplementedKubeClusterNodePoolGcpCommandControllerServer struct {
}

func (UnimplementedKubeClusterNodePoolGcpCommandControllerServer) Add(context.Context, *AddOrUpdateKubeClusterNodePoolGcpCommandInput) (*KubeCluster, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Add not implemented")
}
func (UnimplementedKubeClusterNodePoolGcpCommandControllerServer) Update(context.Context, *AddOrUpdateKubeClusterNodePoolGcpCommandInput) (*KubeCluster, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Update not implemented")
}
func (UnimplementedKubeClusterNodePoolGcpCommandControllerServer) Delete(context.Context, *DeleteKubeClusterNodePoolGcpCommandInput) (*KubeCluster, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Delete not implemented")
}

// UnsafeKubeClusterNodePoolGcpCommandControllerServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to KubeClusterNodePoolGcpCommandControllerServer will
// result in compilation errors.
type UnsafeKubeClusterNodePoolGcpCommandControllerServer interface {
	mustEmbedUnimplementedKubeClusterNodePoolGcpCommandControllerServer()
}

func RegisterKubeClusterNodePoolGcpCommandControllerServer(s grpc.ServiceRegistrar, srv KubeClusterNodePoolGcpCommandControllerServer) {
	s.RegisterService(&KubeClusterNodePoolGcpCommandController_ServiceDesc, srv)
}

func _KubeClusterNodePoolGcpCommandController_Add_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddOrUpdateKubeClusterNodePoolGcpCommandInput)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KubeClusterNodePoolGcpCommandControllerServer).Add(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: KubeClusterNodePoolGcpCommandController_Add_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KubeClusterNodePoolGcpCommandControllerServer).Add(ctx, req.(*AddOrUpdateKubeClusterNodePoolGcpCommandInput))
	}
	return interceptor(ctx, in, info, handler)
}

func _KubeClusterNodePoolGcpCommandController_Update_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddOrUpdateKubeClusterNodePoolGcpCommandInput)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KubeClusterNodePoolGcpCommandControllerServer).Update(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: KubeClusterNodePoolGcpCommandController_Update_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KubeClusterNodePoolGcpCommandControllerServer).Update(ctx, req.(*AddOrUpdateKubeClusterNodePoolGcpCommandInput))
	}
	return interceptor(ctx, in, info, handler)
}

func _KubeClusterNodePoolGcpCommandController_Delete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteKubeClusterNodePoolGcpCommandInput)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KubeClusterNodePoolGcpCommandControllerServer).Delete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: KubeClusterNodePoolGcpCommandController_Delete_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KubeClusterNodePoolGcpCommandControllerServer).Delete(ctx, req.(*DeleteKubeClusterNodePoolGcpCommandInput))
	}
	return interceptor(ctx, in, info, handler)
}

// KubeClusterNodePoolGcpCommandController_ServiceDesc is the grpc.ServiceDesc for KubeClusterNodePoolGcpCommandController service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var KubeClusterNodePoolGcpCommandController_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "cloud.planton.apis.v1.code2cloud.deploy.kubecluster.rpc.KubeClusterNodePoolGcpCommandController",
	HandlerType: (*KubeClusterNodePoolGcpCommandControllerServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "add",
			Handler:    _KubeClusterNodePoolGcpCommandController_Add_Handler,
		},
		{
			MethodName: "update",
			Handler:    _KubeClusterNodePoolGcpCommandController_Update_Handler,
		},
		{
			MethodName: "delete",
			Handler:    _KubeClusterNodePoolGcpCommandController_Delete_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "cloud/planton/apis/v1/code2cloud/deploy/kubecluster/rpc/service.proto",
}

const (
	KubeClusterNodePoolGcpQueryController_GetByGcpContainerNodePoolId_FullMethodName = "/cloud.planton.apis.v1.code2cloud.deploy.kubecluster.rpc.KubeClusterNodePoolGcpQueryController/getByGcpContainerNodePoolId"
)

// KubeClusterNodePoolGcpQueryControllerClient is the client API for KubeClusterNodePoolGcpQueryController service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type KubeClusterNodePoolGcpQueryControllerClient interface {
	// lookup gcp container node pool env using container-nodepool-id
	GetByGcpContainerNodePoolId(ctx context.Context, in *GetByKubeClusterNodePoolGcpIdInput, opts ...grpc.CallOption) (*KubeClusterNodePoolGcp, error)
}

type kubeClusterNodePoolGcpQueryControllerClient struct {
	cc grpc.ClientConnInterface
}

func NewKubeClusterNodePoolGcpQueryControllerClient(cc grpc.ClientConnInterface) KubeClusterNodePoolGcpQueryControllerClient {
	return &kubeClusterNodePoolGcpQueryControllerClient{cc}
}

func (c *kubeClusterNodePoolGcpQueryControllerClient) GetByGcpContainerNodePoolId(ctx context.Context, in *GetByKubeClusterNodePoolGcpIdInput, opts ...grpc.CallOption) (*KubeClusterNodePoolGcp, error) {
	out := new(KubeClusterNodePoolGcp)
	err := c.cc.Invoke(ctx, KubeClusterNodePoolGcpQueryController_GetByGcpContainerNodePoolId_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// KubeClusterNodePoolGcpQueryControllerServer is the server API for KubeClusterNodePoolGcpQueryController service.
// All implementations should embed UnimplementedKubeClusterNodePoolGcpQueryControllerServer
// for forward compatibility
type KubeClusterNodePoolGcpQueryControllerServer interface {
	// lookup gcp container node pool env using container-nodepool-id
	GetByGcpContainerNodePoolId(context.Context, *GetByKubeClusterNodePoolGcpIdInput) (*KubeClusterNodePoolGcp, error)
}

// UnimplementedKubeClusterNodePoolGcpQueryControllerServer should be embedded to have forward compatible implementations.
type UnimplementedKubeClusterNodePoolGcpQueryControllerServer struct {
}

func (UnimplementedKubeClusterNodePoolGcpQueryControllerServer) GetByGcpContainerNodePoolId(context.Context, *GetByKubeClusterNodePoolGcpIdInput) (*KubeClusterNodePoolGcp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetByGcpContainerNodePoolId not implemented")
}

// UnsafeKubeClusterNodePoolGcpQueryControllerServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to KubeClusterNodePoolGcpQueryControllerServer will
// result in compilation errors.
type UnsafeKubeClusterNodePoolGcpQueryControllerServer interface {
	mustEmbedUnimplementedKubeClusterNodePoolGcpQueryControllerServer()
}

func RegisterKubeClusterNodePoolGcpQueryControllerServer(s grpc.ServiceRegistrar, srv KubeClusterNodePoolGcpQueryControllerServer) {
	s.RegisterService(&KubeClusterNodePoolGcpQueryController_ServiceDesc, srv)
}

func _KubeClusterNodePoolGcpQueryController_GetByGcpContainerNodePoolId_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetByKubeClusterNodePoolGcpIdInput)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KubeClusterNodePoolGcpQueryControllerServer).GetByGcpContainerNodePoolId(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: KubeClusterNodePoolGcpQueryController_GetByGcpContainerNodePoolId_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KubeClusterNodePoolGcpQueryControllerServer).GetByGcpContainerNodePoolId(ctx, req.(*GetByKubeClusterNodePoolGcpIdInput))
	}
	return interceptor(ctx, in, info, handler)
}

// KubeClusterNodePoolGcpQueryController_ServiceDesc is the grpc.ServiceDesc for KubeClusterNodePoolGcpQueryController service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var KubeClusterNodePoolGcpQueryController_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "cloud.planton.apis.v1.code2cloud.deploy.kubecluster.rpc.KubeClusterNodePoolGcpQueryController",
	HandlerType: (*KubeClusterNodePoolGcpQueryControllerServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "getByGcpContainerNodePoolId",
			Handler:    _KubeClusterNodePoolGcpQueryController_GetByGcpContainerNodePoolId_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "cloud/planton/apis/v1/code2cloud/deploy/kubecluster/rpc/service.proto",
}

const (
	GcpQueryController_FindRegions_FullMethodName                 = "/cloud.planton.apis.v1.code2cloud.deploy.kubecluster.rpc.GcpQueryController/findRegions"
	GcpQueryController_FindZonesByRegionIdentifier_FullMethodName = "/cloud.planton.apis.v1.code2cloud.deploy.kubecluster.rpc.GcpQueryController/findZonesByRegionIdentifier"
)

// GcpQueryControllerClient is the client API for GcpQueryController service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type GcpQueryControllerClient interface {
	// list all gcp regions
	FindRegions(ctx context.Context, in *custom.CustomEmpty, opts ...grpc.CallOption) (*GcpRegions, error)
	// list all zones in a gcp region
	FindZonesByRegionIdentifier(ctx context.Context, in *GcpRegionIdentifier, opts ...grpc.CallOption) (*GcpZones, error)
}

type gcpQueryControllerClient struct {
	cc grpc.ClientConnInterface
}

func NewGcpQueryControllerClient(cc grpc.ClientConnInterface) GcpQueryControllerClient {
	return &gcpQueryControllerClient{cc}
}

func (c *gcpQueryControllerClient) FindRegions(ctx context.Context, in *custom.CustomEmpty, opts ...grpc.CallOption) (*GcpRegions, error) {
	out := new(GcpRegions)
	err := c.cc.Invoke(ctx, GcpQueryController_FindRegions_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gcpQueryControllerClient) FindZonesByRegionIdentifier(ctx context.Context, in *GcpRegionIdentifier, opts ...grpc.CallOption) (*GcpZones, error) {
	out := new(GcpZones)
	err := c.cc.Invoke(ctx, GcpQueryController_FindZonesByRegionIdentifier_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// GcpQueryControllerServer is the server API for GcpQueryController service.
// All implementations should embed UnimplementedGcpQueryControllerServer
// for forward compatibility
type GcpQueryControllerServer interface {
	// list all gcp regions
	FindRegions(context.Context, *custom.CustomEmpty) (*GcpRegions, error)
	// list all zones in a gcp region
	FindZonesByRegionIdentifier(context.Context, *GcpRegionIdentifier) (*GcpZones, error)
}

// UnimplementedGcpQueryControllerServer should be embedded to have forward compatible implementations.
type UnimplementedGcpQueryControllerServer struct {
}

func (UnimplementedGcpQueryControllerServer) FindRegions(context.Context, *custom.CustomEmpty) (*GcpRegions, error) {
	return nil, status.Errorf(codes.Unimplemented, "method FindRegions not implemented")
}
func (UnimplementedGcpQueryControllerServer) FindZonesByRegionIdentifier(context.Context, *GcpRegionIdentifier) (*GcpZones, error) {
	return nil, status.Errorf(codes.Unimplemented, "method FindZonesByRegionIdentifier not implemented")
}

// UnsafeGcpQueryControllerServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to GcpQueryControllerServer will
// result in compilation errors.
type UnsafeGcpQueryControllerServer interface {
	mustEmbedUnimplementedGcpQueryControllerServer()
}

func RegisterGcpQueryControllerServer(s grpc.ServiceRegistrar, srv GcpQueryControllerServer) {
	s.RegisterService(&GcpQueryController_ServiceDesc, srv)
}

func _GcpQueryController_FindRegions_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(custom.CustomEmpty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GcpQueryControllerServer).FindRegions(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: GcpQueryController_FindRegions_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GcpQueryControllerServer).FindRegions(ctx, req.(*custom.CustomEmpty))
	}
	return interceptor(ctx, in, info, handler)
}

func _GcpQueryController_FindZonesByRegionIdentifier_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GcpRegionIdentifier)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GcpQueryControllerServer).FindZonesByRegionIdentifier(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: GcpQueryController_FindZonesByRegionIdentifier_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GcpQueryControllerServer).FindZonesByRegionIdentifier(ctx, req.(*GcpRegionIdentifier))
	}
	return interceptor(ctx, in, info, handler)
}

// GcpQueryController_ServiceDesc is the grpc.ServiceDesc for GcpQueryController service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var GcpQueryController_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "cloud.planton.apis.v1.code2cloud.deploy.kubecluster.rpc.GcpQueryController",
	HandlerType: (*GcpQueryControllerServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "findRegions",
			Handler:    _GcpQueryController_FindRegions_Handler,
		},
		{
			MethodName: "findZonesByRegionIdentifier",
			Handler:    _GcpQueryController_FindZonesByRegionIdentifier_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "cloud/planton/apis/v1/code2cloud/deploy/kubecluster/rpc/service.proto",
}

const (
	KubeClusterStackController_Preview_FullMethodName = "/cloud.planton.apis.v1.code2cloud.deploy.kubecluster.rpc.KubeClusterStackController/preview"
	KubeClusterStackController_Apply_FullMethodName   = "/cloud.planton.apis.v1.code2cloud.deploy.kubecluster.rpc.KubeClusterStackController/apply"
)

// KubeClusterStackControllerClient is the client API for KubeClusterStackController service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type KubeClusterStackControllerClient interface {
	// preview kube-cluster stack with provided spec
	Preview(ctx context.Context, in *KubeCluster, opts ...grpc.CallOption) (*KubeCluster, error)
	// apply kube-cluster stack
	Apply(ctx context.Context, in *KubeClusterId, opts ...grpc.CallOption) (*KubeCluster, error)
}

type kubeClusterStackControllerClient struct {
	cc grpc.ClientConnInterface
}

func NewKubeClusterStackControllerClient(cc grpc.ClientConnInterface) KubeClusterStackControllerClient {
	return &kubeClusterStackControllerClient{cc}
}

func (c *kubeClusterStackControllerClient) Preview(ctx context.Context, in *KubeCluster, opts ...grpc.CallOption) (*KubeCluster, error) {
	out := new(KubeCluster)
	err := c.cc.Invoke(ctx, KubeClusterStackController_Preview_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *kubeClusterStackControllerClient) Apply(ctx context.Context, in *KubeClusterId, opts ...grpc.CallOption) (*KubeCluster, error) {
	out := new(KubeCluster)
	err := c.cc.Invoke(ctx, KubeClusterStackController_Apply_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// KubeClusterStackControllerServer is the server API for KubeClusterStackController service.
// All implementations should embed UnimplementedKubeClusterStackControllerServer
// for forward compatibility
type KubeClusterStackControllerServer interface {
	// preview kube-cluster stack with provided spec
	Preview(context.Context, *KubeCluster) (*KubeCluster, error)
	// apply kube-cluster stack
	Apply(context.Context, *KubeClusterId) (*KubeCluster, error)
}

// UnimplementedKubeClusterStackControllerServer should be embedded to have forward compatible implementations.
type UnimplementedKubeClusterStackControllerServer struct {
}

func (UnimplementedKubeClusterStackControllerServer) Preview(context.Context, *KubeCluster) (*KubeCluster, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Preview not implemented")
}
func (UnimplementedKubeClusterStackControllerServer) Apply(context.Context, *KubeClusterId) (*KubeCluster, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Apply not implemented")
}

// UnsafeKubeClusterStackControllerServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to KubeClusterStackControllerServer will
// result in compilation errors.
type UnsafeKubeClusterStackControllerServer interface {
	mustEmbedUnimplementedKubeClusterStackControllerServer()
}

func RegisterKubeClusterStackControllerServer(s grpc.ServiceRegistrar, srv KubeClusterStackControllerServer) {
	s.RegisterService(&KubeClusterStackController_ServiceDesc, srv)
}

func _KubeClusterStackController_Preview_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(KubeCluster)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KubeClusterStackControllerServer).Preview(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: KubeClusterStackController_Preview_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KubeClusterStackControllerServer).Preview(ctx, req.(*KubeCluster))
	}
	return interceptor(ctx, in, info, handler)
}

func _KubeClusterStackController_Apply_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(KubeClusterId)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KubeClusterStackControllerServer).Apply(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: KubeClusterStackController_Apply_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KubeClusterStackControllerServer).Apply(ctx, req.(*KubeClusterId))
	}
	return interceptor(ctx, in, info, handler)
}

// KubeClusterStackController_ServiceDesc is the grpc.ServiceDesc for KubeClusterStackController service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var KubeClusterStackController_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "cloud.planton.apis.v1.code2cloud.deploy.kubecluster.rpc.KubeClusterStackController",
	HandlerType: (*KubeClusterStackControllerServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "preview",
			Handler:    _KubeClusterStackController_Preview_Handler,
		},
		{
			MethodName: "apply",
			Handler:    _KubeClusterStackController_Apply_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "cloud/planton/apis/v1/code2cloud/deploy/kubecluster/rpc/service.proto",
}
